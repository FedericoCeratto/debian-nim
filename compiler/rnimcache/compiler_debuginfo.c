/* Generated by Nim Compiler v0.13.0 */
/*   (c) 2015 Andreas Rumpf */
/* The generated code is subject to the original license. */
/* Compiled for: Linux, amd64, gcc */
/* Command for C compiler:
   gcc -c  -w -O3 -fno-strict-aliasing  -I/home/ubuntu/nim-ci/Nim/lib -o /home/ubuntu/nim-ci/Nim/compiler/rnimcache/compiler_debuginfo.o /home/ubuntu/nim-ci/Nim/compiler/rnimcache/compiler_debuginfo.c */
#define NIM_INTBITS 64

#include "nimbase.h"
#include <string.h>
#include <stdio.h>
typedef struct Debuginfo204010 Debuginfo204010;
typedef struct TY204022 TY204022;
typedef struct TY204024 TY204024;
typedef struct Filenamemapping204006 Filenamemapping204006;
typedef struct NimStringDesc NimStringDesc;
typedef struct TGenericSeq TGenericSeq;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
typedef struct Enumdesc204008 Enumdesc204008;
typedef struct TY204018 TY204018;
typedef struct TY204019 TY204019;
typedef struct Cell47305 Cell47305;
typedef struct Cellseq47321 Cellseq47321;
typedef struct Gcheap49818 Gcheap49818;
typedef struct Gcstack49816 Gcstack49816;
typedef struct Memregion29480 Memregion29480;
typedef struct Smallchunk29437 Smallchunk29437;
typedef struct Llchunk29474 Llchunk29474;
typedef struct Bigchunk29439 Bigchunk29439;
typedef struct Intset29414 Intset29414;
typedef struct Trunk29410 Trunk29410;
typedef struct Avlnode29478 Avlnode29478;
typedef struct Gcstat49814 Gcstat49814;
typedef struct Cellset47317 Cellset47317;
typedef struct Pagedesc47313 Pagedesc47313;
typedef struct Filestreamobj157876 Filestreamobj157876;
typedef struct Streamobj156818 Streamobj156818;
typedef struct Basechunk29435 Basechunk29435;
typedef struct Freecell29427 Freecell29427;
typedef struct TNimObject TNimObject;
struct  Debuginfo204010  {
NI version;
TY204022* files;
TY204024* enums;
NIM_BOOL conflicts;
};
struct  TGenericSeq  {
NI len;
NI reserved;
};
struct  NimStringDesc  {
  TGenericSeq Sup;
NIM_CHAR data[SEQ_DECL_SIZE];
};
struct  Filenamemapping204006  {
NimStringDesc* package;
NimStringDesc* file;
NU32 mangled;
};
typedef N_NIMCALL_PTR(void, TY3489) (void* p, NI op);
typedef N_NIMCALL_PTR(void*, TY3494) (void* p);
struct  TNimType  {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
TY3489 marker;
TY3494 deepcopy;
};
struct  TNimNode  {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
struct  Enumdesc204008  {
NI size;
NU32 owner;
NI id;
NimStringDesc* name;
TY204018* values;
};
struct TY204019 {
NimStringDesc* Field0;
NI Field1;
};
struct  Cell47305  {
NI refcount;
TNimType* typ;
};
struct  Cellseq47321  {
NI len;
NI cap;
Cell47305** d;
};
typedef Smallchunk29437* TY29495[512];
typedef Trunk29410* Trunkbuckets29412[256];
struct  Intset29414  {
Trunkbuckets29412 data;
};
struct  Memregion29480  {
NI minlargeobj;
NI maxlargeobj;
TY29495 freesmallchunks;
Llchunk29474* llmem;
NI currmem;
NI maxmem;
NI freemem;
NI lastsize;
Bigchunk29439* freechunkslist;
Intset29414 chunkstarts;
Avlnode29478* root;
Avlnode29478* deleted;
Avlnode29478* last;
Avlnode29478* freeavlnodes;
NIM_BOOL locked;
};
struct  Gcstat49814  {
NI stackscans;
NI cyclecollections;
NI maxthreshold;
NI maxstacksize;
NI maxstackcells;
NI cycletablesize;
NI64 maxpause;
};
struct  Cellset47317  {
NI counter;
NI max;
Pagedesc47313* head;
Pagedesc47313** data;
};
struct  Gcheap49818  {
Gcstack49816* stack;
void* stackbottom;
NI cyclethreshold;
Cellseq47321 zct;
Cellseq47321 decstack;
Cellseq47321 tempstack;
NI recgclock;
Memregion29480 region;
Gcstat49814 stat;
Cellset47317 marked;
Cellseq47321 additionalroots;
};
struct  Gcstack49816  {
Gcstack49816* prev;
Gcstack49816* next;
void* starts;
void* pos;
NI maxstacksize;
};
struct  Basechunk29435  {
NI prevsize;
NI size;
NIM_BOOL used;
};
struct  Smallchunk29437  {
  Basechunk29435 Sup;
Smallchunk29437* next;
Smallchunk29437* prev;
Freecell29427* freelist;
NI free;
NI acc;
NF data;
};
struct  Llchunk29474  {
NI size;
NI acc;
Llchunk29474* next;
};
struct  Bigchunk29439  {
  Basechunk29435 Sup;
Bigchunk29439* next;
Bigchunk29439* prev;
NI align;
NF data;
};
typedef NI TY29419[8];
struct  Trunk29410  {
Trunk29410* next;
NI key;
TY29419 bits;
};
typedef Avlnode29478* TY29485[2];
struct  Avlnode29478  {
TY29485 link;
NI key;
NI upperbound;
NI level;
};
struct  Pagedesc47313  {
Pagedesc47313* next;
NI key;
TY29419 bits;
};
struct  TNimObject  {
TNimType* m_type;
};
typedef N_NIMCALL_PTR(void, TY156819) (Streamobj156818* s);
typedef N_NIMCALL_PTR(NIM_BOOL, TY156823) (Streamobj156818* s);
typedef N_NIMCALL_PTR(void, TY156827) (Streamobj156818* s, NI pos);
typedef N_NIMCALL_PTR(NI, TY156832) (Streamobj156818* s);
typedef N_NIMCALL_PTR(NI, TY156836) (Streamobj156818* s, void* buffer, NI buflen);
typedef N_NIMCALL_PTR(NI, TY156842) (Streamobj156818* s, void* buffer, NI buflen);
typedef N_NIMCALL_PTR(void, TY156848) (Streamobj156818* s, void* buffer, NI buflen);
typedef N_NIMCALL_PTR(void, TY156854) (Streamobj156818* s);
struct  Streamobj156818  {
  TNimObject Sup;
TY156819 closeimpl;
TY156823 atendimpl;
TY156827 setpositionimpl;
TY156832 getpositionimpl;
TY156836 readdataimpl;
TY156842 peekdataimpl;
TY156848 writedataimpl;
TY156854 flushimpl;
};
struct  Filestreamobj157876  {
  Streamobj156818 Sup;
FILE* f;
};
struct  Freecell29427  {
Freecell29427* next;
NI zerofield;
};
struct TY204022 {
  TGenericSeq Sup;
  Filenamemapping204006 data[SEQ_DECL_SIZE];
};
struct TY204024 {
  TGenericSeq Sup;
  Enumdesc204008 data[SEQ_DECL_SIZE];
};
struct TY204018 {
  TGenericSeq Sup;
  TY204019 data[SEQ_DECL_SIZE];
};
N_NIMCALL(void, init_204434)(Debuginfo204010* self);
N_NIMCALL(void, nimGCvisit)(void* d, NI op);
N_NIMCALL(void, TMP526)(void* p, NI op);
N_NIMCALL(void*, newSeq)(TNimType* typ, NI len);
N_NIMCALL(void, unsureAsgnRef)(void** dest, void* src);
N_NIMCALL(void, TMP529)(void* p, NI op);
N_NIMCALL(void, TMP530)(void* p, NI op);
N_NIMCALL(NU32, sdbmhash_204078)(NimStringDesc* package, NimStringDesc* file);
static N_INLINE(NU32, sdbmhash_204027)(NU32 hash, NIM_CHAR c);
static N_INLINE(NIM_BOOL, eqStrings)(NimStringDesc* a, NimStringDesc* b);
static N_INLINE(NIM_BOOL, equalmem_7488)(void* a, void* b, NI size);
N_NIMCALL(NimStringDesc*, copyString)(NimStringDesc* src);
N_NIMCALL(TGenericSeq*, incrSeqV2)(TGenericSeq* seq, NI elemsize);
N_NIMCALL(NimStringDesc*, copyStringRC1)(NimStringDesc* src);
static N_INLINE(void, nimGCunrefNoCycle)(void* p);
static N_INLINE(Cell47305*, usrtocell_51440)(void* usr);
static N_INLINE(void, rtladdzct_52601)(Cell47305* c);
N_NOINLINE(void, addzct_51417)(Cellseq47321* s, Cell47305* c);
N_NIMCALL(void, genericAssign)(void* dest, void* src, TNimType* mt);
N_NIMCALL(void, writedebuginfo_273001)(Debuginfo204010* self, NimStringDesc* file);
N_NIMCALL(Filestreamobj157876*, newfilestream_157941)(NimStringDesc* filename, NU8 mode);
N_NIMCALL(void, store_273008)(Streamobj156818* s, Debuginfo204010* data);
N_NIMCALL(void, close_156870)(Streamobj156818* s);
Debuginfo204010 gdebuginfo_204470;
TNimType NTI204006; /* FilenameMapping */
extern TNimType NTI138; /* string */
TNimType NTI204004; /* FilenameHash */
TNimType NTI204022; /* seq[FilenameMapping] */
TNimType NTI204008; /* EnumDesc */
extern TNimType NTI104; /* int */
TNimType NTI204019; /* (string, int) */
TNimType NTI204018; /* seq[(string, int)] */
TNimType NTI204024; /* seq[EnumDesc] */
extern Gcheap49818 gch_49855;
TNimType NTI204010; /* DebugInfo */
extern TNimType NTI130; /* bool */
N_NIMCALL(void, TMP526)(void* p, NI op) {
	TY204022* a;
	NI LOC1;
	a = (TY204022*)p;
	LOC1 = 0;
	for (LOC1 = 0; LOC1 < a->Sup.len; LOC1++) {
	nimGCvisit((void*)a->data[LOC1].package, op);
	nimGCvisit((void*)a->data[LOC1].file, op);
	}
}
N_NIMCALL(void, TMP529)(void* p, NI op) {
	TY204018* a;
	NI LOC1;
	a = (TY204018*)p;
	LOC1 = 0;
	for (LOC1 = 0; LOC1 < a->Sup.len; LOC1++) {
	nimGCvisit((void*)a->data[LOC1].Field0, op);
	}
}
N_NIMCALL(void, TMP530)(void* p, NI op) {
	TY204024* a;
	NI LOC1;
	a = (TY204024*)p;
	LOC1 = 0;
	for (LOC1 = 0; LOC1 < a->Sup.len; LOC1++) {
	nimGCvisit((void*)a->data[LOC1].name, op);
	nimGCvisit((void*)a->data[LOC1].values, op);
	}
}

N_NIMCALL(void, init_204434)(Debuginfo204010* self) {
	(*self).version = ((NI) 1);
	unsureAsgnRef((void**) (&(*self).files), (TY204022*) newSeq((&NTI204022), 0));
	unsureAsgnRef((void**) (&(*self).enums), (TY204024*) newSeq((&NTI204024), 0));
}

static N_INLINE(NU32, sdbmhash_204027)(NU32 hash, NIM_CHAR c) {
	NU32 result;
{	result = 0;
	result = (NU32)((NU32)((unsigned int)((NU32)((unsigned int)((NU32)(((NU32) (((NU8)(c))))) + (NU32)((NU32)((NU64)(hash) << (NU64)(((NI) 6)))))) + (NU32)((NU32)((NU64)(hash) << (NU64)(((NI) 16)))))) - (NU32)(hash));
	goto BeforeRet;
	}BeforeRet: ;
	return result;
}

N_NIMCALL(NU32, sdbmhash_204078)(NimStringDesc* package, NimStringDesc* file) {
	NU32 result;
	result = 0;
	result = ((NU32) 0);
	{
		NI i_204099;
		NI HEX3Atmp_204111;
		NI i_204114;
		i_204099 = 0;
		HEX3Atmp_204111 = 0;
		HEX3Atmp_204111 = (package ? package->Sup.len : 0);
		i_204114 = ((NI) 0);
		{
			while (1) {
				if (!(i_204114 < HEX3Atmp_204111)) goto LA3;
				i_204099 = i_204114;
				result = sdbmhash_204027(result, package->data[i_204099]);
				i_204114 += ((NI) 1);
			} LA3: ;
		}
	}
	result = sdbmhash_204027(result, 46);
	{
		NI i_204109;
		NI HEX3Atmp_204117;
		NI i_204120;
		i_204109 = 0;
		HEX3Atmp_204117 = 0;
		HEX3Atmp_204117 = (file ? file->Sup.len : 0);
		i_204120 = ((NI) 0);
		{
			while (1) {
				if (!(i_204120 < HEX3Atmp_204117)) goto LA6;
				i_204109 = i_204120;
				result = sdbmhash_204027(result, file->data[i_204109]);
				i_204120 += ((NI) 1);
			} LA6: ;
		}
	}
	return result;
}

static N_INLINE(NIM_BOOL, equalmem_7488)(void* a, void* b, NI size) {
	NIM_BOOL result;
	int LOC1;
	result = 0;
	LOC1 = 0;
	LOC1 = memcmp(a, b, ((size_t) (size)));
	result = (LOC1 == ((NI32) 0));
	return result;
}

static N_INLINE(NIM_BOOL, eqStrings)(NimStringDesc* a, NimStringDesc* b) {
	NIM_BOOL result;
	NIM_BOOL LOC11;
{	result = 0;
	{
		if (!(a == b)) goto LA3;
		result = NIM_TRUE;
		goto BeforeRet;
	}
	LA3: ;
	{
		NIM_BOOL LOC7;
		LOC7 = 0;
		LOC7 = (a == NIM_NIL);
		if (LOC7) goto LA8;
		LOC7 = (b == NIM_NIL);
		LA8: ;
		if (!LOC7) goto LA9;
		result = NIM_FALSE;
		goto BeforeRet;
	}
	LA9: ;
	LOC11 = 0;
	LOC11 = ((*a).Sup.len == (*b).Sup.len);
	if (!(LOC11)) goto LA12;
	LOC11 = equalmem_7488(((void*) ((*a).data)), ((void*) ((*b).data)), ((NI) ((*a).Sup.len)));
	LA12: ;
	result = LOC11;
	goto BeforeRet;
	}BeforeRet: ;
	return result;
}

static N_INLINE(Cell47305*, usrtocell_51440)(void* usr) {
	Cell47305* result;
	result = 0;
	result = ((Cell47305*) ((NI)((NU64)(((NI) (usr))) - (NU64)(((NI)sizeof(Cell47305))))));
	return result;
}

static N_INLINE(void, rtladdzct_52601)(Cell47305* c) {
	addzct_51417((&gch_49855.zct), c);
}

static N_INLINE(void, nimGCunrefNoCycle)(void* p) {
	Cell47305* c;
	c = usrtocell_51440(p);
	{
		(*c).refcount -= ((NI) 8);
		if (!((NU64)((*c).refcount) < (NU64)(((NI) 8)))) goto LA3;
		rtladdzct_52601(c);
	}
	LA3: ;
}

N_NIMCALL(NU32, register_204122)(Debuginfo204010* self, NimStringDesc* package, NimStringDesc* file) {
	NU32 result;
	Filenamemapping204006 LOC14;
	NimStringDesc* LOC15;
	NimStringDesc* LOC16;
{	result = 0;
	result = sdbmhash_204078(package, file);
	{
		Filenamemapping204006 f_204202;
		TY204022* HEX3Atmp_204223;
		NI i_204226;
		NI L_204228;
		memset((void*)(&f_204202), 0, sizeof(f_204202));
		HEX3Atmp_204223 = 0;
		HEX3Atmp_204223 = (*self).files;
		i_204226 = ((NI) 0);
		L_204228 = (HEX3Atmp_204223 ? HEX3Atmp_204223->Sup.len : 0);
		{
			while (1) {
				if (!(i_204226 < L_204228)) goto LA3;
				f_204202.package = HEX3Atmp_204223->data[i_204226].package;
				f_204202.file = HEX3Atmp_204223->data[i_204226].file;
				f_204202.mangled = HEX3Atmp_204223->data[i_204226].mangled;
				{
					if (!(f_204202.mangled == result)) goto LA6;
					{
						NIM_BOOL LOC10;
						LOC10 = 0;
						LOC10 = eqStrings(f_204202.package, package);
						if (!(LOC10)) goto LA11;
						LOC10 = eqStrings(f_204202.file, file);
						LA11: ;
						if (!LOC10) goto LA12;
						goto BeforeRet;
					}
					LA12: ;
					(*self).conflicts = NIM_TRUE;
					goto LA1;
				}
				LA6: ;
				i_204226 += ((NI) 1);
			} LA3: ;
		}
	} LA1: ;
	memset((void*)(&LOC14), 0, sizeof(LOC14));
	memset((void*)(&LOC14), 0, sizeof(LOC14));
	LOC14.package = copyString(package);
	LOC14.file = copyString(file);
	LOC14.mangled = result;
	(*self).files = (TY204022*) incrSeqV2(&((*self).files)->Sup, sizeof(Filenamemapping204006));
	LOC15 = 0;
	LOC15 = (*self).files->data[(*self).files->Sup.len].package; (*self).files->data[(*self).files->Sup.len].package = copyStringRC1(LOC14.package);
	if (LOC15) nimGCunrefNoCycle(LOC15);
	LOC16 = 0;
	LOC16 = (*self).files->data[(*self).files->Sup.len].file; (*self).files->data[(*self).files->Sup.len].file = copyStringRC1(LOC14.file);
	if (LOC16) nimGCunrefNoCycle(LOC16);
	(*self).files->data[(*self).files->Sup.len].mangled = LOC14.mangled;
	++(*self).files->Sup.len;
	}BeforeRet: ;
	return result;
}

N_NIMCALL(NIM_BOOL, hasenum_204230)(Debuginfo204010* self, NimStringDesc* ename, NI id, NU32 owner) {
	NIM_BOOL result;
{	result = 0;
	{
		Enumdesc204008 en_204402;
		TY204024* HEX3Atmp_204413;
		NI i_204416;
		NI L_204418;
		memset((void*)(&en_204402), 0, sizeof(en_204402));
		HEX3Atmp_204413 = 0;
		HEX3Atmp_204413 = (*self).enums;
		i_204416 = ((NI) 0);
		L_204418 = (HEX3Atmp_204413 ? HEX3Atmp_204413->Sup.len : 0);
		{
			while (1) {
				if (!(i_204416 < L_204418)) goto LA3;
				memcpy((void*)(&en_204402), (NIM_CONST void*)(&HEX3Atmp_204413->data[i_204416]), sizeof(en_204402));
				{
					NIM_BOOL LOC6;
					NIM_BOOL LOC7;
					LOC6 = 0;
					LOC7 = 0;
					LOC7 = (en_204402.owner == owner);
					if (!(LOC7)) goto LA8;
					LOC7 = eqStrings(en_204402.name, ename);
					LA8: ;
					LOC6 = LOC7;
					if (!(LOC6)) goto LA9;
					LOC6 = (en_204402.id == id);
					LA9: ;
					if (!LOC6) goto LA10;
					result = NIM_TRUE;
					goto BeforeRet;
				}
				LA10: ;
				i_204416 += ((NI) 1);
			} LA3: ;
		}
	}
	}BeforeRet: ;
	return result;
}

N_NIMCALL(void, registerenum_204419)(Debuginfo204010* self, Enumdesc204008* ed) {
	(*self).enums = (TY204024*) incrSeqV2(&((*self).enums)->Sup, sizeof(Enumdesc204008));
	genericAssign((void*)(&(*self).enums->data[(*self).enums->Sup.len]), (void*)ed, (&NTI204008));
	++(*self).enums->Sup.len;
}

N_NIMCALL(void, writedebuginfo_273001)(Debuginfo204010* self, NimStringDesc* file) {
	Filestreamobj157876* s;
	Streamobj156818* LOC1;
	Streamobj156818* LOC2;
	s = newfilestream_157941(file, ((NU8) 1));
	LOC1 = 0;
	LOC1 = &s->Sup;
	store_273008(LOC1, (&(*self)));
	LOC2 = 0;
	LOC2 = &s->Sup;
	close_156870(LOC2);
}

N_NIMCALL(void, writedebuginfo_273037)(NimStringDesc* file) {
	writedebuginfo_273001((&gdebuginfo_204470), file);
}
NIM_EXTERNC N_NOINLINE(void, compiler_debuginfoInit000)(void) {
	init_204434((&gdebuginfo_204470));
}

NIM_EXTERNC N_NOINLINE(void, compiler_debuginfoDatInit000)(void) {
static TNimNode* TMP525[3];
static TNimNode* TMP527[5];
static TNimNode* TMP528[2];
static TNimNode* TMP4750[4];
static TNimNode TMP523[18];
NTI204006.size = sizeof(Filenamemapping204006);
NTI204006.kind = 18;
NTI204006.base = 0;
NTI204006.flags = 2;
TMP525[0] = &TMP523[1];
TMP523[1].kind = 1;
TMP523[1].offset = offsetof(Filenamemapping204006, package);
TMP523[1].typ = (&NTI138);
TMP523[1].name = "package";
TMP525[1] = &TMP523[2];
TMP523[2].kind = 1;
TMP523[2].offset = offsetof(Filenamemapping204006, file);
TMP523[2].typ = (&NTI138);
TMP523[2].name = "file";
TMP525[2] = &TMP523[3];
NTI204004.size = sizeof(NU32);
NTI204004.kind = 43;
NTI204004.base = 0;
NTI204004.flags = 3;
TMP523[3].kind = 1;
TMP523[3].offset = offsetof(Filenamemapping204006, mangled);
TMP523[3].typ = (&NTI204004);
TMP523[3].name = "mangled";
TMP523[0].len = 3; TMP523[0].kind = 2; TMP523[0].sons = &TMP525[0];
NTI204006.node = &TMP523[0];
NTI204022.size = sizeof(TY204022*);
NTI204022.kind = 24;
NTI204022.base = (&NTI204006);
NTI204022.flags = 2;
NTI204022.marker = TMP526;
NTI204008.size = sizeof(Enumdesc204008);
NTI204008.kind = 18;
NTI204008.base = 0;
NTI204008.flags = 2;
TMP527[0] = &TMP523[5];
TMP523[5].kind = 1;
TMP523[5].offset = offsetof(Enumdesc204008, size);
TMP523[5].typ = (&NTI104);
TMP523[5].name = "size";
TMP527[1] = &TMP523[6];
TMP523[6].kind = 1;
TMP523[6].offset = offsetof(Enumdesc204008, owner);
TMP523[6].typ = (&NTI204004);
TMP523[6].name = "owner";
TMP527[2] = &TMP523[7];
TMP523[7].kind = 1;
TMP523[7].offset = offsetof(Enumdesc204008, id);
TMP523[7].typ = (&NTI104);
TMP523[7].name = "id";
TMP527[3] = &TMP523[8];
TMP523[8].kind = 1;
TMP523[8].offset = offsetof(Enumdesc204008, name);
TMP523[8].typ = (&NTI138);
TMP523[8].name = "name";
TMP527[4] = &TMP523[9];
NTI204019.size = sizeof(TY204019);
NTI204019.kind = 18;
NTI204019.base = 0;
NTI204019.flags = 2;
TMP528[0] = &TMP523[11];
TMP523[11].kind = 1;
TMP523[11].offset = offsetof(TY204019, Field0);
TMP523[11].typ = (&NTI138);
TMP523[11].name = "Field0";
TMP528[1] = &TMP523[12];
TMP523[12].kind = 1;
TMP523[12].offset = offsetof(TY204019, Field1);
TMP523[12].typ = (&NTI104);
TMP523[12].name = "Field1";
TMP523[10].len = 2; TMP523[10].kind = 2; TMP523[10].sons = &TMP528[0];
NTI204019.node = &TMP523[10];
NTI204018.size = sizeof(TY204018*);
NTI204018.kind = 24;
NTI204018.base = (&NTI204019);
NTI204018.flags = 2;
NTI204018.marker = TMP529;
TMP523[9].kind = 1;
TMP523[9].offset = offsetof(Enumdesc204008, values);
TMP523[9].typ = (&NTI204018);
TMP523[9].name = "values";
TMP523[4].len = 5; TMP523[4].kind = 2; TMP523[4].sons = &TMP527[0];
NTI204008.node = &TMP523[4];
NTI204024.size = sizeof(TY204024*);
NTI204024.kind = 24;
NTI204024.base = (&NTI204008);
NTI204024.flags = 2;
NTI204024.marker = TMP530;
NTI204010.size = sizeof(Debuginfo204010);
NTI204010.kind = 18;
NTI204010.base = 0;
NTI204010.flags = 2;
TMP4750[0] = &TMP523[14];
TMP523[14].kind = 1;
TMP523[14].offset = offsetof(Debuginfo204010, version);
TMP523[14].typ = (&NTI104);
TMP523[14].name = "version";
TMP4750[1] = &TMP523[15];
TMP523[15].kind = 1;
TMP523[15].offset = offsetof(Debuginfo204010, files);
TMP523[15].typ = (&NTI204022);
TMP523[15].name = "files";
TMP4750[2] = &TMP523[16];
TMP523[16].kind = 1;
TMP523[16].offset = offsetof(Debuginfo204010, enums);
TMP523[16].typ = (&NTI204024);
TMP523[16].name = "enums";
TMP4750[3] = &TMP523[17];
TMP523[17].kind = 1;
TMP523[17].offset = offsetof(Debuginfo204010, conflicts);
TMP523[17].typ = (&NTI130);
TMP523[17].name = "conflicts";
TMP523[13].len = 4; TMP523[13].kind = 2; TMP523[13].sons = &TMP4750[0];
NTI204010.node = &TMP523[13];
}

