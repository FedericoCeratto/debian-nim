/* Generated by Nim Compiler v0.12.0 */
/*   (c) 2015 Andreas Rumpf */
/* The generated code is subject to the original license. */
#define NIM_INTBITS 64

#include "nimbase.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <setjmp.h>
typedef struct Table190452 Table190452;
typedef struct Keyvaluepairseq190455 Keyvaluepairseq190455;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
typedef struct TY190615 TY190615;
typedef struct Tfileinfo190350 Tfileinfo190350;
typedef struct NimStringDesc NimStringDesc;
typedef struct TGenericSeq TGenericSeq;
typedef struct Ropeobj176009 Ropeobj176009;
typedef struct TY190365 TY190365;
typedef struct Cell49146 Cell49146;
typedef struct Cellseq49162 Cellseq49162;
typedef struct Gcheap51218 Gcheap51218;
typedef struct Gcstack51216 Gcstack51216;
typedef struct Cellset49158 Cellset49158;
typedef struct Pagedesc49154 Pagedesc49154;
typedef struct Memregion31091 Memregion31091;
typedef struct Smallchunk31043 Smallchunk31043;
typedef struct Llchunk31085 Llchunk31085;
typedef struct Bigchunk31045 Bigchunk31045;
typedef struct Intset31017 Intset31017;
typedef struct Trunk31013 Trunk31013;
typedef struct Avlnode31089 Avlnode31089;
typedef struct Gcstat51214 Gcstat51214;
typedef struct Tlineinfo190352 Tlineinfo190352;
typedef struct TY191417 TY191417;
typedef struct Erecoverableerror190358 Erecoverableerror190358;
typedef struct Valueerror4049 Valueerror4049;
typedef struct Exception Exception;
typedef struct TNimObject TNimObject;
typedef struct Slice196011 Slice196011;
typedef struct TSafePoint TSafePoint;
typedef struct TY91159 TY91159;
typedef struct Esuggestdone190360 Esuggestdone190360;
typedef struct Keyvaluepair190458 Keyvaluepair190458;
typedef struct Basechunk31041 Basechunk31041;
typedef struct Freecell31033 Freecell31033;
struct  Table190452  {
Keyvaluepairseq190455* data;
NI counter;
};
typedef N_NIMCALL_PTR(void, TY3889) (void* p, NI op);
typedef N_NIMCALL_PTR(void*, TY3894) (void* p);
struct  TNimType  {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
TY3889 marker;
TY3894 deepcopy;
};
struct  TNimNode  {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
struct  TGenericSeq  {
NI len;
NI reserved;
};
struct  NimStringDesc  {
  TGenericSeq Sup;
NIM_CHAR data[SEQ_DECL_SIZE];
};
struct  Tfileinfo190350  {
NimStringDesc* fullpath;
NimStringDesc* projpath;
NimStringDesc* shortname;
Ropeobj176009* quotedname;
TY190365* lines;
NimStringDesc* dirtyfile;
};
struct  Cell49146  {
NI refcount;
TNimType* typ;
};
struct  Cellseq49162  {
NI len;
NI cap;
Cell49146** d;
};
struct  Cellset49158  {
NI counter;
NI max;
Pagedesc49154* head;
Pagedesc49154** data;
};
typedef Smallchunk31043* TY31106[512];
typedef Trunk31013* Trunkbuckets31015[256];
struct  Intset31017  {
Trunkbuckets31015 data;
};
struct  Memregion31091  {
NI minlargeobj;
NI maxlargeobj;
TY31106 freesmallchunks;
Llchunk31085* llmem;
NI currmem;
NI maxmem;
NI freemem;
NI lastsize;
Bigchunk31045* freechunkslist;
Intset31017 chunkstarts;
Avlnode31089* root;
Avlnode31089* deleted;
Avlnode31089* last;
Avlnode31089* freeavlnodes;
};
struct  Gcstat51214  {
NI stackscans;
NI cyclecollections;
NI maxthreshold;
NI maxstacksize;
NI maxstackcells;
NI cycletablesize;
NI64 maxpause;
};
struct  Gcheap51218  {
Gcstack51216* stack;
void* stackbottom;
NI cyclethreshold;
Cellseq49162 zct;
Cellseq49162 decstack;
Cellset49158 cycleroots;
Cellseq49162 tempstack;
NI recgclock;
Memregion31091 region;
Gcstat51214 stat;
};
struct  Tlineinfo190352  {
NI16 line;
NI16 col;
NI32 fileindex;
};
typedef struct {
N_NIMCALL_PTR(void, ClPrc) (NimStringDesc* output, void* ClEnv);
void* ClEnv;
} TY191438;
typedef struct {
N_NIMCALL_PTR(void, ClPrc) (NU8 err, NimStringDesc* msg, NIM_BOOL usewarning, void* ClEnv);
void* ClEnv;
} TY176023;
typedef NimStringDesc* TY193306[2];
typedef NimStringDesc* TY193293[3];
typedef NimStringDesc* TY190303[291];
typedef NimStringDesc* TY192421[1];
typedef N_CLOSURE_PTR(void, TMP429) (NimStringDesc* output);
typedef NimStringDesc* TY190311[31];
typedef NimStringDesc* TY190317[23];
typedef N_CLOSURE_PTR(void, TMP492) (NimStringDesc* output);
typedef N_CLOSURE_PTR(void, TMP493) (NimStringDesc* output);
typedef N_CLOSURE_PTR(void, TMP496) (NimStringDesc* output);
typedef N_CLOSURE_PTR(void, TMP497) (NimStringDesc* output);
typedef N_CLOSURE_PTR(void, TMP498) (NimStringDesc* output);
struct  TNimObject  {
TNimType* m_type;
};
struct  Exception  {
  TNimObject Sup;
Exception* parent;
NCSTRING name;
NimStringDesc* message;
NimStringDesc* trace;
};
struct  Valueerror4049  {
  Exception Sup;
};
struct  Erecoverableerror190358  {
  Valueerror4049 Sup;
};
typedef N_CLOSURE_PTR(void, TMP501) (NU8 err, NimStringDesc* msg, NIM_BOOL usewarning, void* ClEnv);
typedef NimStringDesc* TY194829[4];
typedef N_CLOSURE_PTR(void, TMP1045) (NimStringDesc* output);
typedef N_CLOSURE_PTR(void, TMP1046) (NimStringDesc* output);
struct  Slice196011  {
NU16 a;
NU16 b;
};
typedef N_CLOSURE_PTR(void, TMP1047) (NimStringDesc* output);
typedef struct {
N_NIMCALL_PTR(NIM_BOOL, ClPrc) (Exception* e, void* ClEnv);
void* ClEnv;
} TY19411;
struct  TSafePoint  {
TSafePoint* prev;
NI status;
jmp_buf context;
NIM_BOOL hasRaiseAction;
TY19411 raiseAction;
};
struct TY91159 {
NimStringDesc* Field0;
NI Field1;
};
typedef NU64 TY190379[4];
typedef N_CLOSURE_PTR(void, TMP2061) (NimStringDesc* output);
struct  Esuggestdone190360  {
  Exception Sup;
};
struct Keyvaluepair190458 {
NI Field0;
NimStringDesc* Field1;
NI32 Field2;
};
struct  Ropeobj176009  {
  TNimObject Sup;
Ropeobj176009* left;
Ropeobj176009* right;
NI length;
NimStringDesc* data;
};
struct  Gcstack51216  {
Gcstack51216* prev;
Gcstack51216* next;
void* starts;
void* pos;
NI maxstacksize;
};
typedef NI TY31022[8];
struct  Pagedesc49154  {
Pagedesc49154* next;
NI key;
TY31022 bits;
};
struct  Basechunk31041  {
NI prevsize;
NI size;
NIM_BOOL used;
};
struct  Smallchunk31043  {
  Basechunk31041 Sup;
Smallchunk31043* next;
Smallchunk31043* prev;
Freecell31033* freelist;
NI free;
NI acc;
NF data;
};
struct  Llchunk31085  {
NI size;
NI acc;
Llchunk31085* next;
};
struct  Bigchunk31045  {
  Basechunk31041 Sup;
Bigchunk31045* next;
Bigchunk31045* prev;
NI align;
NF data;
};
struct  Trunk31013  {
Trunk31013* next;
NI key;
TY31022 bits;
};
typedef Avlnode31089* TY31096[2];
struct  Avlnode31089  {
TY31096 link;
NI key;
NI upperbound;
NI level;
};
struct  Freecell31033  {
Freecell31033* next;
NI zerofield;
};
struct TY190615 {
  TGenericSeq Sup;
  Tfileinfo190350 data[SEQ_DECL_SIZE];
};
struct TY190365 {
  TGenericSeq Sup;
  Ropeobj176009* data[SEQ_DECL_SIZE];
};
struct TY191417 {
  TGenericSeq Sup;
  Tlineinfo190352 data[SEQ_DECL_SIZE];
};
struct Keyvaluepairseq190455 {
  TGenericSeq Sup;
  Keyvaluepair190458 data[SEQ_DECL_SIZE];
};
N_NIMCALL(void, inittable_190444)(NI initialsize, Table190452* Result);
N_NOINLINE(void, chckNil)(void* p);
N_NIMCALL(void, genericReset)(void* dest, TNimType* mt);
N_NIMCALL(void, nimGCvisit)(void* d, NI op);
N_NIMCALL(void, TMP144)(void* p, NI op);
N_NIMCALL(void, TMP145)(void* p, NI op);
static N_INLINE(void, nimGCunrefNoCycle)(void* p);
static N_INLINE(Cell49146*, usrtocell_52846)(void* usr);
static N_INLINE(void, rtladdzct_54404)(Cell49146* c);
N_NOINLINE(void, addzct_52817)(Cellseq49162* s, Cell49146* c);
N_NIMCALL(void*, newSeqRC1)(TNimType* typ, NI len);
N_NIMCALL(void, newfileinfo_190694)(NimStringDesc* fullpath, NimStringDesc* projpath, Tfileinfo190350* Result);
N_NIMCALL(void, unsureAsgnRef)(void** dest, void* src);
N_NIMCALL(NimStringDesc*, copyString)(NimStringDesc* src);
N_NIMCALL(NimStringDesc*, nosextractFilename)(NimStringDesc* path);
N_NIMCALL(NimStringDesc*, noschangeFileExt)(NimStringDesc* filename, NimStringDesc* ext);
N_NIMCALL(Ropeobj176009*, makecstring_190649)(NimStringDesc* s);
N_NIMCALL(NimStringDesc*, rawNewString)(NI space);
N_NIMCALL(NimStringDesc*, rawNewString)(NI cap);
static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src);
N_NIMCALL(NimStringDesc*, resizeString)(NimStringDesc* dest, NI addlen);
N_NIMCALL(NimStringDesc*, addChar)(NimStringDesc* s, NIM_CHAR c);
N_NIMCALL(NimStringDesc*, tocchar_190639)(NIM_CHAR c);
static N_INLINE(void, appendChar)(NimStringDesc* dest, NIM_CHAR c);
N_NIMCALL(NimStringDesc*, nsuToOctal)(NIM_CHAR c);
N_NIMCALL(NimStringDesc*, nimCharToStr)(NIM_CHAR x);
N_NIMCALL(void, add_176534)(Ropeobj176009** a, Ropeobj176009* b);
N_NIMCALL(Ropeobj176009*, rope_176322)(NimStringDesc* s);
N_NIMCALL(void*, newSeq)(TNimType* typ, NI len);
N_NIMCALL(TGenericSeq*, incrSeqV2)(TGenericSeq* seq, NI elemsize);
N_NIMCALL(void, genericAssign)(void* dest, void* src, TNimType* mt);
N_NIMCALL(Tlineinfo190352, newlineinfo_191266)(NI32 fileinfoidx, NI line, NI col);
N_NIMCALL(void, TMP152)(void* p, NI op);
N_NIMCALL(Tlineinfo190352, unknownlineinfo_191408)(void);
N_NIMCALL(void, HEX3Aanonymous_196653)(NU8 err, NimStringDesc* msg, NIM_BOOL usewarning);
N_NIMCALL(void, internalerror_196191)(NimStringDesc* errmsg);
N_NIMCALL(void, writecontext_193266)(Tlineinfo190352 lastinfo);
N_NIMCALL(NIM_BOOL, HEX3DHEX3D_193255)(Tlineinfo190352 a, Tlineinfo190352 b);
N_NIMCALL(NimStringDesc*, nsuFormatOpenArray)(NimStringDesc* formatstr, NimStringDesc** a, NI aLen0);
N_NIMCALL(NimStringDesc*, tomsgfilename_191829)(Tlineinfo190352 info);
N_NIMCALL(NimStringDesc*, coordtostr_192396)(NI coord);
N_NIMCALL(NimStringDesc*, nimIntToStr)(NI x);
N_NIMCALL(NimStringDesc*, getmessagestr_192416)(NU16 msg, NimStringDesc* arg);
N_NIMCALL(NimStringDesc*, msgkindtostring_192406)(NU16 kind);
static N_INLINE(void, writeline_168405)(FILE* f, NimStringDesc** x, NI xLen0);
N_NIMCALL(void, write_17095)(FILE* f, NimStringDesc* s);
N_NIMCALL(void, setstyle_187604)(FILE* f, NU8 style);
N_NIMCALL(void, resetattributes_187209)(FILE* f);
N_NIMCALL(void, rawmessage_194636)(NU16 msg, NimStringDesc* arg);
N_NIMCALL(void, rawmessage_193675)(NU16 msg, NimStringDesc** args, NI argsLen0);
N_NIMCALL(NIM_BOOL, ignoremsgbecauseofidetools_193637)(NU16 msg);
N_NIMCALL(NimStringDesc*, nsuFormatSingleElem)(NimStringDesc* formatstr, NimStringDesc* a);
N_NIMCALL(void, setforegroundcolor_188057)(FILE* f, NU8 fg, NIM_BOOL bright);
N_NIMCALL(void, handleerror_192437)(NU16 msg, NU8 eh, NimStringDesc* s_192441);
N_NIMCALL(NIM_BOOL, stacktraceavailable_21930)(void);
N_NIMCALL(void, writestacktrace_20407)(void);
N_NOINLINE(void, raiserecoverableerror_191366)(NimStringDesc* msg) __attribute__((noreturn));
N_NIMCALL(void, TMP499)(void* p, NI op);
N_NIMCALL(void*, newObj)(TNimType* typ, NI size);
N_NIMCALL(NimStringDesc*, copyStringRC1)(NimStringDesc* src);
N_NIMCALL(void, raiseException)(Exception* e, NCSTRING ename);
static N_INLINE(void, asgnRef)(void** dest, void* src);
static N_INLINE(void, incref_55222)(Cell49146* c);
static N_INLINE(NIM_BOOL, canbecycleroot_52867)(Cell49146* c);
static N_INLINE(void, rtladdcycleroot_53623)(Cell49146* c);
N_NOINLINE(void, incl_49865)(Cellset49158* s, Cell49146* cell);
static N_INLINE(void, decref_54804)(Cell49146* c);
N_NIMCALL(NIM_BOOL, isatty_188426)(FILE* f);
N_NIMCALL(void, limessage_194706)(Tlineinfo190352 info, NU16 msg, NimStringDesc* arg, NU8 eh);
static N_INLINE(NIM_BOOL, contains_196021)(Slice196011 s, NU16 value);
static N_INLINE(Slice196011, HEX2EHEX2E_196002)(NU16 a, NU16 b);
N_NIMCALL(void, writesurroundingsrc_194681)(Tlineinfo190352 info);
N_NIMCALL(void, msgwriteln_191915)(NimStringDesc* s, NU8 flags);
N_NIMCALL(NimStringDesc*, HEX24_177132)(Ropeobj176009* r);
N_NIMCALL(Ropeobj176009*, sourceline_191389)(Tlineinfo190352 i);
static N_INLINE(void, pushSafePoint)(TSafePoint* s);
N_NIMCALL(NimStringDesc*, tofullpath_191662)(NI32 fileidx);
N_NIMCALL(FILE*, open_17017)(NimStringDesc* filename, NU8 mode, NI bufsize);
N_NIMCALL(NIM_BOOL, readline_17119)(FILE* f, NimStringDesc** line);
N_NIMCALL(void, addsourceline_196227)(NI32 fileidx, NimStringDesc* line);
static N_INLINE(void, asgnRefNoCycle)(void** dest, void* src);
static N_INLINE(void, popSafePoint)(void);
N_NIMCALL(NIM_BOOL, isObj)(TNimType* obj, TNimType* subclass);
static N_INLINE(Exception*, getCurrentException)(void);
static N_INLINE(void, popCurrentException)(void);
N_NIMCALL(void, reraiseException)(void);
N_NIMCALL(NimStringDesc*, HEX24_196279)(TY91159 x);
N_NIMCALL(NimStringDesc*, nsuRepeatChar)(NIM_CHAR c, NI count);
N_NIMCALL(NI32, fileinfoidx_190732)(NimStringDesc* filename, NIM_BOOL* isknownfile);
N_NIMCALL(NimStringDesc*, canonicalizepath_167409)(NimStringDesc* path);
static N_INLINE(void, shallow_91824)(NimStringDesc** s_91827);
N_NIMCALL(NIM_BOOL, haskey_190742)(Table190452 t, NimStringDesc* key);
N_NIMCALL(NI32*, HEX5BHEX5D_190786)(Table190452* t, NimStringDesc* key);
N_NIMCALL(NimStringDesc*, shortendir_167607)(NimStringDesc* dir);
N_NIMCALL(void, HEX5BHEX5DHEX3D_191038)(Table190452* t, NimStringDesc* key, NI32 val);
N_NIMCALL(TGenericSeq*, setLengthSeq)(TGenericSeq* seq, NI elemsize, NI newlen);
N_NIMCALL(void, TMP2771)(void* p, NI op);
static N_INLINE(NimStringDesc*, tofilelinecol_191869)(Tlineinfo190352 info);
N_NIMCALL(NimStringDesc*, tofilename_191652)(NI32 fileidx);
STRING_LITERAL(TMP147, "", 0);
STRING_LITERAL(TMP148, "\"", 1);
STRING_LITERAL(TMP149, "command line", 12);
STRING_LITERAL(TMP150, "compilation artifact", 20);
STRING_LITERAL(TMP154, "$1($2, $3) ", 11);
STRING_LITERAL(TMP155, "???", 3);
STRING_LITERAL(TMP156, "unknown error", 13);
STRING_LITERAL(TMP157, "illformed AST: $1", 17);
STRING_LITERAL(TMP158, "internal error: $1", 18);
STRING_LITERAL(TMP159, "cannot open \'$1\'", 16);
STRING_LITERAL(TMP160, "$1", 2);
STRING_LITERAL(TMP161, "\'$1\' compiler does not support C++", 34);
STRING_LITERAL(TMP162, "string literal expected", 23);
STRING_LITERAL(TMP163, "integer literal expected", 24);
STRING_LITERAL(TMP164, "invalid character constant", 26);
STRING_LITERAL(TMP165, "closing \"\"\" expected, but end of file reached", 45);
STRING_LITERAL(TMP166, "closing \" expected", 18);
STRING_LITERAL(TMP167, "tabulators are not allowed", 26);
STRING_LITERAL(TMP168, "invalid token: $1", 17);
STRING_LITERAL(TMP169, "line too long", 13);
STRING_LITERAL(TMP170, "$1 is not a valid number", 24);
STRING_LITERAL(TMP171, "$1 is not a valid number; did you mean octal? Then use one of \'"
"0o\', \'0c\' or \'0C\'.", 81);
STRING_LITERAL(TMP172, "number $1 out of valid range", 28);
STRING_LITERAL(TMP173, "\\n not allowed in character literal", 35);
STRING_LITERAL(TMP174, "closing \']\' expected, but end of file reached", 45);
STRING_LITERAL(TMP175, "missing final \' for character literal", 37);
STRING_LITERAL(TMP176, "identifier expected, but found \'$1\'", 35);
STRING_LITERAL(TMP177, "newline expected, but found \'$1\'", 32);
STRING_LITERAL(TMP178, "invalid module name: \'$1\'", 25);
STRING_LITERAL(TMP179, "operator expected, but found \'$1\'", 33);
STRING_LITERAL(TMP180, "\'$1\' expected", 13);
STRING_LITERAL(TMP181, "string after \'include\' expected", 31);
STRING_LITERAL(TMP182, "recursive dependency: \'$1\'", 26);
STRING_LITERAL(TMP183, "\'on\' or \'off\' expected", 22);
STRING_LITERAL(TMP184, "\'none\', \'speed\' or \'size\' expected", 34);
STRING_LITERAL(TMP185, "invalid pragma", 14);
STRING_LITERAL(TMP186, "unknown pragma: \'$1\'", 20);
STRING_LITERAL(TMP187, "invalid directive: \'$1\'", 23);
STRING_LITERAL(TMP188, "\'pop\' without a \'push\' pragma", 29);
STRING_LITERAL(TMP189, "empty asm statement", 19);
STRING_LITERAL(TMP190, "invalid indentation", 19);
STRING_LITERAL(TMP191, "exception expected", 18);
STRING_LITERAL(TMP192, "exception already handled", 25);
STRING_LITERAL(TMP193, "\'yield\' only allowed in an iterator", 35);
STRING_LITERAL(TMP194, "\'yield\' cannot be used within \'try\' in a non-inlined iterator", 61);
STRING_LITERAL(TMP195, "invalid number of \'yield\' expressions", 37);
STRING_LITERAL(TMP196, "current routine cannot return an expression", 43);
STRING_LITERAL(TMP197, "redefinition of \'$1\'", 20);
STRING_LITERAL(TMP198, "statement not allowed after \'return\', \'break\', \'raise\' or \'cont"
"inue\'", 68);
STRING_LITERAL(TMP199, "statement expected", 18);
STRING_LITERAL(TMP200, "\'$1\' is no label", 16);
STRING_LITERAL(TMP201, "invalid command line option: \'$1\'", 33);
STRING_LITERAL(TMP202, "argument for command line option expected: \'$1\'", 47);
STRING_LITERAL(TMP203, "invalid argument for command line option: \'$1\'", 46);
STRING_LITERAL(TMP204, "invalid variable substitution in \'$1\'", 37);
STRING_LITERAL(TMP205, "unknown variable: \'$1\'", 22);
STRING_LITERAL(TMP206, "unknown C compiler: \'$1\'", 24);
STRING_LITERAL(TMP207, "\'on\' or \'off\' expected, but \'$1\' found", 38);
STRING_LITERAL(TMP208, "\'on\', \'off\' or \'list\' expected, but \'$1\' found", 46);
STRING_LITERAL(TMP209, "\'none\', \'boehm\' or \'refc\' expected, but \'$1\' found", 50);
STRING_LITERAL(TMP210, "\'none\', \'speed\' or \'size\' expected, but \'$1\' found", 50);
STRING_LITERAL(TMP211, "\'gui\', \'console\' or \'lib\' expected, but \'$1\' found", 50);
STRING_LITERAL(TMP212, "unknown OS: \'$1\'", 16);
STRING_LITERAL(TMP213, "unknown CPU: \'$1\'", 17);
STRING_LITERAL(TMP214, "\'c\', \'c++\' or \'yaml\' expected, but \'$1\' found", 45);
STRING_LITERAL(TMP215, "arguments can only be given if the \'--run\' option is selected", 61);
STRING_LITERAL(TMP216, "multiple assignment is not allowed", 34);
STRING_LITERAL(TMP217, "\':\' or \'=\' expected, but found \'$1\'", 35);
STRING_LITERAL(TMP218, "expression expected, but found \'$1\'", 35);
STRING_LITERAL(TMP219, "undeclared identifier: \'$1\'", 27);
STRING_LITERAL(TMP220, "undeclared field: \'$1\'", 22);
STRING_LITERAL(TMP221, "attempting to call undeclared routine: \'$1\'", 43);
STRING_LITERAL(TMP222, "ambiguous identifier: \'$1\' -- use a qualifier", 45);
STRING_LITERAL(TMP223, "type expected", 13);
STRING_LITERAL(TMP224, "system module needs \'$1\'", 24);
STRING_LITERAL(TMP225, "execution of an external program failed: \'$1\'", 45);
STRING_LITERAL(TMP226, "overloaded \'$1\' leads to ambiguous calls", 40);
STRING_LITERAL(TMP227, "invalid argument for \'$1\'", 25);
STRING_LITERAL(TMP228, "statement has no effect", 23);
STRING_LITERAL(TMP229, "\'$1\' expects a type or value", 28);
STRING_LITERAL(TMP230, "\'$1\' expects an array type", 26);
STRING_LITERAL(TMP231, "\'$1\' cannot be instantiated because its body has not been compi"
"led yet", 70);
STRING_LITERAL(TMP232, "expression \'$1\' ambiguous in this context", 41);
STRING_LITERAL(TMP233, "division by zero", 16);
STRING_LITERAL(TMP234, "ordinal type expected", 21);
STRING_LITERAL(TMP235, "ordinal or float type expected", 30);
STRING_LITERAL(TMP236, "over- or underflow", 18);
STRING_LITERAL(TMP237, "cannot evalutate \'$1\' because type is not defined completely", 60);
STRING_LITERAL(TMP238, "\'chr\' expects an int in the range 0..255", 40);
STRING_LITERAL(TMP239, "\'dynlib\' requires \'exportc\'", 27);
STRING_LITERAL(TMP240, "attempt to access a nil address", 31);
STRING_LITERAL(TMP241, "index out of bounds", 19);
STRING_LITERAL(TMP242, "index types do not match", 24);
STRING_LITERAL(TMP243, "\'[]\' operator invalid for this type", 35);
STRING_LITERAL(TMP244, "value out of set bounds", 23);
STRING_LITERAL(TMP245, "field initialized twice: \'$1\'", 29);
STRING_LITERAL(TMP246, "field \'$1\' not initialized", 26);
STRING_LITERAL(TMP247, "expression \'$1\' cannot be called", 32);
STRING_LITERAL(TMP248, "expression has no type", 22);
STRING_LITERAL(TMP249, "expression \'$1\' has no type (or is ambiguous)", 45);
STRING_LITERAL(TMP250, "\'cast\' not allowed in safe mode", 31);
STRING_LITERAL(TMP251, "expression cannot be casted to $1", 33);
STRING_LITERAL(TMP252, "\',\' or \')\' expected", 19);
STRING_LITERAL(TMP253, "\'{\' or \'(\' expected", 19);
STRING_LITERAL(TMP254, "section (\'type\', \'proc\', etc.) expected", 39);
STRING_LITERAL(TMP255, "range expected", 14);
STRING_LITERAL(TMP256, "\'magic\' only allowed in system module", 37);
STRING_LITERAL(TMP257, "power of two expected", 21);
STRING_LITERAL(TMP258, "string literal may not be empty", 31);
STRING_LITERAL(TMP259, "calling convention expected", 27);
STRING_LITERAL(TMP260, "a proc can only have one calling convention", 43);
STRING_LITERAL(TMP261, "symbol must be imported if \'lib\' pragma is used", 47);
STRING_LITERAL(TMP262, "expression must be of type \'bool\'", 33);
STRING_LITERAL(TMP263, "constant expression expected", 28);
STRING_LITERAL(TMP264, "duplicate case label", 20);
STRING_LITERAL(TMP265, "range is empty", 14);
STRING_LITERAL(TMP266, "selector must be of an ordinal type, float or string", 52);
STRING_LITERAL(TMP267, "selector must be of an ordinal type", 35);
STRING_LITERAL(TMP268, "ord($1) must not be negative", 28);
STRING_LITERAL(TMP269, "len($1) must be less than 32768", 31);
STRING_LITERAL(TMP270, "wrong number of variables", 25);
STRING_LITERAL(TMP271, "only a \'ref object\' can be raised", 33);
STRING_LITERAL(TMP272, "\'break\' only allowed in loop construct", 38);
STRING_LITERAL(TMP273, "type \'$1\' has unknown size", 26);
STRING_LITERAL(TMP274, "a constant can only be initialized with a constant expression", 61);
STRING_LITERAL(TMP275, "a constant needs a value", 24);
STRING_LITERAL(TMP276, "the result type cannot be on open array", 39);
STRING_LITERAL(TMP277, "computing the type\'s size produced an overflow", 46);
STRING_LITERAL(TMP278, "set is too large", 16);
STRING_LITERAL(TMP279, "base type of a set must be an ordinal", 37);
STRING_LITERAL(TMP280, "inheritance only works with non-final objects", 45);
STRING_LITERAL(TMP281, "inheritance only works with an enum", 35);
STRING_LITERAL(TMP282, "illegal recursion in type \'$1\'", 30);
STRING_LITERAL(TMP283, "cannot instantiate: \'$1\'", 24);
STRING_LITERAL(TMP284, "expression has no address", 25);
STRING_LITERAL(TMP285, "address of \'$1\' may not escape its stack frame", 46);
STRING_LITERAL(TMP286, "for a \'var\' type a variable needs to be passed", 46);
STRING_LITERAL(TMP287, "type mismatch", 13);
STRING_LITERAL(TMP288, "type mismatch: got (", 20);
STRING_LITERAL(TMP289, "but expected one of: ", 21);
STRING_LITERAL(TMP290, "but expected \'$1\'", 17);
STRING_LITERAL(TMP291, "ambiguous call; both $1 and $2 match for: $3", 44);
STRING_LITERAL(TMP292, "wrong number of arguments", 25);
STRING_LITERAL(TMP293, "\'$1\' cannot be passed to a procvar", 34);
STRING_LITERAL(TMP294, "$1 cannot be declared in parameter declaration", 46);
STRING_LITERAL(TMP295, "pragmas are only allowed in the header of a proc", 48);
STRING_LITERAL(TMP296, "implementation of \'$1\' is not allowed", 37);
STRING_LITERAL(TMP297, "implementation of \'$1\' expected", 31);
STRING_LITERAL(TMP298, "no symbol to borrow from found", 30);
STRING_LITERAL(TMP299, "value of type \'$1\' has to be discarded", 38);
STRING_LITERAL(TMP300, "statement returns no value that can be discarded", 48);
STRING_LITERAL(TMP301, "conversion from $1 to $2 is invalid", 35);
STRING_LITERAL(TMP302, "cannot bind parameter \'$1\' twice", 32);
STRING_LITERAL(TMP303, "invalid order in array constructor", 34);
STRING_LITERAL(TMP304, "invalid order in enum \'$1\'", 26);
STRING_LITERAL(TMP305, "enum \'$1\' has holes", 19);
STRING_LITERAL(TMP306, "\'except\' or \'finally\' expected", 30);
STRING_LITERAL(TMP307, "after catch all \'except\' or \'finally\' no section may follow", 59);
STRING_LITERAL(TMP308, "option expected, but found \'$1\'", 31);
STRING_LITERAL(TMP309, "\'$1\' is not a label", 19);
STRING_LITERAL(TMP310, "not all cases are covered", 25);
STRING_LITERAL(TMP311, "unknown substitution variable: \'$1\'", 35);
STRING_LITERAL(TMP312, "complex statement requires indentation", 38);
STRING_LITERAL(TMP313, "\'$1\' is not callable", 20);
STRING_LITERAL(TMP314, "no pragmas allowed for $1", 25);
STRING_LITERAL(TMP315, "no generic parameters allowed for $1", 36);
STRING_LITERAL(TMP316, "invalid param kind: \'$1\'", 24);
STRING_LITERAL(TMP317, "default argument invalid", 24);
STRING_LITERAL(TMP318, "named parameter has to be an identifier", 39);
STRING_LITERAL(TMP319, "no return type allowed for $1", 29);
STRING_LITERAL(TMP320, "a type conversion needs exactly one argument", 44);
STRING_LITERAL(TMP321, "invalid pragma: $1", 18);
STRING_LITERAL(TMP322, "$1 not allowed here", 19);
STRING_LITERAL(TMP323, "invalid control flow: $1", 24);
STRING_LITERAL(TMP324, "invalid type: \'$1\'", 18);
STRING_LITERAL(TMP325, "\'[]\' needs a pointer or reference type", 38);
STRING_LITERAL(TMP326, "invalid expression", 18);
STRING_LITERAL(TMP327, "invalid expression: \'$1\'", 24);
STRING_LITERAL(TMP328, "enum has no value \'$1\'", 22);
STRING_LITERAL(TMP329, "named expression expected", 25);
STRING_LITERAL(TMP330, "named expression not allowed here", 33);
STRING_LITERAL(TMP331, "\'$1\' expects one type parameter", 31);
STRING_LITERAL(TMP332, "array expects two type parameters", 33);
STRING_LITERAL(TMP333, "invalid visibility: \'$1\'", 24);
STRING_LITERAL(TMP334, "initialization not allowed here", 31);
STRING_LITERAL(TMP335, "\'$1\' cannot be assigned to", 26);
STRING_LITERAL(TMP336, "iterators can only be defined at the module\'s top level", 55);
STRING_LITERAL(TMP337, "$1 needs a return type", 22);
STRING_LITERAL(TMP338, "no return type declared", 23);
STRING_LITERAL(TMP339, "no command given", 16);
STRING_LITERAL(TMP340, "invalid command: \'$1\'", 21);
STRING_LITERAL(TMP341, "\'$1\' is only allowed at top level", 33);
STRING_LITERAL(TMP342, "\'$1\' needs a parameter that has an object type", 46);
STRING_LITERAL(TMP343, "template/macro instantiation too nested", 39);
STRING_LITERAL(TMP344, "template/generic instantiation from here", 40);
STRING_LITERAL(TMP345, "invalid index value for tuple subscript", 39);
STRING_LITERAL(TMP346, "command expects a filename argument", 35);
STRING_LITERAL(TMP347, "please, specify a main module in the project configuration file", 63);
STRING_LITERAL(TMP348, "\'$1\' is not a concrete type.", 28);
STRING_LITERAL(TMP349, "invalid section start", 21);
STRING_LITERAL(TMP350, "grid table is not implemented", 29);
STRING_LITERAL(TMP351, "general parse error", 19);
STRING_LITERAL(TMP352, "new section expected", 20);
STRING_LITERAL(TMP353, "whitespace expected, got \'$1\'", 29);
STRING_LITERAL(TMP354, "\'$1\' is no valid index file", 27);
STRING_LITERAL(TMP355, "cannot render reStructuredText element \'$1\'", 43);
STRING_LITERAL(TMP356, "type \'var var\' is not allowed", 29);
STRING_LITERAL(TMP357, "instantiate \'$1\' explicitly", 27);
STRING_LITERAL(TMP358, "only a call operator can be a delegator", 39);
STRING_LITERAL(TMP359, "\'$1\' is not a variable, constant or a proc name", 47);
STRING_LITERAL(TMP360, "the macro body cannot be compiled, because the parameter \'$1\' h"
"as a generic type", 80);
STRING_LITERAL(TMP361, "Destructor signature is too specific. A destructor must be asso"
"ciated will all instantiations of a generic type", 111);
STRING_LITERAL(TMP362, "inline iterators can be used as parameters only for templates, "
"macros and other inline iterators", 96);
STRING_LITERAL(TMP363, "\'$1\' expects two arguments", 26);
STRING_LITERAL(TMP364, "\'$1\' expects object types", 25);
STRING_LITERAL(TMP365, "\'$1\' can never be of this subtype", 33);
STRING_LITERAL(TMP366, "interpretation requires too many iterations", 43);
STRING_LITERAL(TMP367, "cannot evaluate \'$1\'", 20);
STRING_LITERAL(TMP368, "field \'$1\' cannot be found", 26);
STRING_LITERAL(TMP369, "invalid conversion from type \'$1\'", 33);
STRING_LITERAL(TMP370, "assertion failed", 16);
STRING_LITERAL(TMP371, "cannot generate code for \'$1\'", 29);
STRING_LITERAL(TMP372, "$1 requires one parameter", 25);
STRING_LITERAL(TMP373, "unhandled exception: $1", 23);
STRING_LITERAL(TMP374, "macro returned a cyclic abstract syntax tree", 44);
STRING_LITERAL(TMP375, "\'$1\' is no macro or template", 28);
STRING_LITERAL(TMP376, "\'$1\' can have side effects", 26);
STRING_LITERAL(TMP377, "iterator within for loop context expected", 41);
STRING_LITERAL(TMP378, "\'let\' symbol requires an initialization", 39);
STRING_LITERAL(TMP379, "a thread var cannot be initialized explicitly", 45);
STRING_LITERAL(TMP380, "usage of \'$1\' is a user-defined error", 37);
STRING_LITERAL(TMP381, "illegal capture \'$1\'", 20);
STRING_LITERAL(TMP382, "\'$1\' cannot have \'closure\' calling convention", 45);
STRING_LITERAL(TMP383, "\'$1\' can only be used in compile-time context", 45);
STRING_LITERAL(TMP384, "cannot infer the type of the $1", 31);
STRING_LITERAL(TMP385, "cannot infer the return type of the proc", 40);
STRING_LITERAL(TMP386, "A nested proc can have generic parameters only when it is used "
"as an operand to another routine and the types of the generic pa"
"ramers can be inferred from the expected signature.", 178);
STRING_LITERAL(TMP387, "The current compiler \'$1\' doesn\'t support the requested compila"
"tion target", 74);
STRING_LITERAL(TMP388, "External assembler not found", 28);
STRING_LITERAL(TMP389, "External assembler \'$1\' is not a valid assembler", 48);
STRING_LITERAL(TMP390, "octal escape sequences do not exist; leading zero is ignored", 60);
STRING_LITERAL(TMP391, "\'$1\' is never read", 18);
STRING_LITERAL(TMP392, "\'$1\' might not have been initialized", 36);
STRING_LITERAL(TMP393, "$1 is deprecated", 16);
STRING_LITERAL(TMP394, "config file \'$1\' is deprecated", 30);
STRING_LITERAL(TMP395, "\'l\' should not be used as an identifier; may look like \'1\' (one"
")", 64);
STRING_LITERAL(TMP396, "unknown magic \'$1\' might crash the compiler", 43);
STRING_LITERAL(TMP397, "redefinition of label \'$1\'", 26);
STRING_LITERAL(TMP398, "unknown substitution \'$1\'", 25);
STRING_LITERAL(TMP399, "language \'$1\' not supported", 27);
STRING_LITERAL(TMP400, "field \'$1\' not supported", 24);
STRING_LITERAL(TMP401, "comment \'$1\' ignored", 20);
STRING_LITERAL(TMP402, "\'nil\' statement is deprecated; use an empty \'discard\' statement"
" instead", 71);
STRING_LITERAL(TMP403, "\'$1\' has no type. Typeless parameters are deprecated; only allo"
"wed for \'template\'", 81);
STRING_LITERAL(TMP404, "use {.base.} for base methods; baseless methods are deprecated", 62);
STRING_LITERAL(TMP405, "write to foreign heap", 21);
STRING_LITERAL(TMP406, "unsafe code: \'$1\'", 17);
STRING_LITERAL(TMP407, "each identifier is a tuple", 26);
STRING_LITERAL(TMP408, "shadowed identifier: \'$1\'", 25);
STRING_LITERAL(TMP409, "Cannot prove that \'$1\' is initialized. This will become a compi"
"le time error in the future.", 91);
STRING_LITERAL(TMP410, "cannot prove that field \'$1\' is accessible", 42);
STRING_LITERAL(TMP411, "cannot prove index \'$1\' is valid", 32);
STRING_LITERAL(TMP412, "not GC-safe: \'$1\'", 17);
STRING_LITERAL(TMP413, "\'$1\' uses GC\'ed memory", 22);
STRING_LITERAL(TMP414, "usage of a type with a destructor in a non destructible context"
". This will become a compile time error in the future.", 117);
STRING_LITERAL(TMP415, "Special variable \'result\' is shadowed.", 38);
STRING_LITERAL(TMP416, "operation successful", 20);
STRING_LITERAL(TMP417, "operation successful ($# lines compiled; $# sec total; $#; $#)", 62);
STRING_LITERAL(TMP418, "\'$1\' is declared but not used", 29);
STRING_LITERAL(TMP419, "conversion to base object is not needed", 39);
STRING_LITERAL(TMP420, "conversion from $1 to itself is pointless", 41);
STRING_LITERAL(TMP421, "expression evaluates always to \'$1\'", 35);
STRING_LITERAL(TMP422, "quit() called", 13);
STRING_LITERAL(TMP423, "generated code listing:", 23);
STRING_LITERAL(TMP424, "end of listing", 14);
STRING_LITERAL(TMP425, "used config file \'$1\'", 21);
STRING_LITERAL(TMP426, "added path: \'$1\'", 16);
STRING_LITERAL(TMP427, "condition is always true: \'$1\'", 30);
STRING_LITERAL(TMP428, "name should be: \'$1\'", 20);
NIM_CONST TY190303 Msgkindtostr_190300 = {((NimStringDesc*) &TMP156),
((NimStringDesc*) &TMP157),
((NimStringDesc*) &TMP158),
((NimStringDesc*) &TMP159),
((NimStringDesc*) &TMP160),
((NimStringDesc*) &TMP161),
((NimStringDesc*) &TMP162),
((NimStringDesc*) &TMP163),
((NimStringDesc*) &TMP164),
((NimStringDesc*) &TMP165),
((NimStringDesc*) &TMP166),
((NimStringDesc*) &TMP167),
((NimStringDesc*) &TMP168),
((NimStringDesc*) &TMP169),
((NimStringDesc*) &TMP170),
((NimStringDesc*) &TMP171),
((NimStringDesc*) &TMP172),
((NimStringDesc*) &TMP173),
((NimStringDesc*) &TMP174),
((NimStringDesc*) &TMP175),
((NimStringDesc*) &TMP176),
((NimStringDesc*) &TMP177),
((NimStringDesc*) &TMP178),
((NimStringDesc*) &TMP179),
((NimStringDesc*) &TMP180),
((NimStringDesc*) &TMP181),
((NimStringDesc*) &TMP182),
((NimStringDesc*) &TMP183),
((NimStringDesc*) &TMP184),
((NimStringDesc*) &TMP185),
((NimStringDesc*) &TMP186),
((NimStringDesc*) &TMP187),
((NimStringDesc*) &TMP188),
((NimStringDesc*) &TMP189),
((NimStringDesc*) &TMP190),
((NimStringDesc*) &TMP191),
((NimStringDesc*) &TMP192),
((NimStringDesc*) &TMP193),
((NimStringDesc*) &TMP194),
((NimStringDesc*) &TMP195),
((NimStringDesc*) &TMP196),
((NimStringDesc*) &TMP197),
((NimStringDesc*) &TMP198),
((NimStringDesc*) &TMP199),
((NimStringDesc*) &TMP200),
((NimStringDesc*) &TMP201),
((NimStringDesc*) &TMP202),
((NimStringDesc*) &TMP203),
((NimStringDesc*) &TMP204),
((NimStringDesc*) &TMP205),
((NimStringDesc*) &TMP206),
((NimStringDesc*) &TMP207),
((NimStringDesc*) &TMP208),
((NimStringDesc*) &TMP209),
((NimStringDesc*) &TMP210),
((NimStringDesc*) &TMP211),
((NimStringDesc*) &TMP212),
((NimStringDesc*) &TMP213),
((NimStringDesc*) &TMP214),
((NimStringDesc*) &TMP215),
((NimStringDesc*) &TMP216),
((NimStringDesc*) &TMP217),
((NimStringDesc*) &TMP218),
((NimStringDesc*) &TMP219),
((NimStringDesc*) &TMP220),
((NimStringDesc*) &TMP221),
((NimStringDesc*) &TMP222),
((NimStringDesc*) &TMP223),
((NimStringDesc*) &TMP224),
((NimStringDesc*) &TMP225),
((NimStringDesc*) &TMP226),
((NimStringDesc*) &TMP227),
((NimStringDesc*) &TMP228),
((NimStringDesc*) &TMP229),
((NimStringDesc*) &TMP230),
((NimStringDesc*) &TMP231),
((NimStringDesc*) &TMP232),
((NimStringDesc*) &TMP233),
((NimStringDesc*) &TMP234),
((NimStringDesc*) &TMP235),
((NimStringDesc*) &TMP236),
((NimStringDesc*) &TMP237),
((NimStringDesc*) &TMP238),
((NimStringDesc*) &TMP239),
((NimStringDesc*) &TMP220),
((NimStringDesc*) &TMP240),
((NimStringDesc*) &TMP241),
((NimStringDesc*) &TMP242),
((NimStringDesc*) &TMP243),
((NimStringDesc*) &TMP244),
((NimStringDesc*) &TMP245),
((NimStringDesc*) &TMP246),
((NimStringDesc*) &TMP247),
((NimStringDesc*) &TMP248),
((NimStringDesc*) &TMP249),
((NimStringDesc*) &TMP250),
((NimStringDesc*) &TMP251),
((NimStringDesc*) &TMP252),
((NimStringDesc*) &TMP253),
((NimStringDesc*) &TMP254),
((NimStringDesc*) &TMP255),
((NimStringDesc*) &TMP256),
((NimStringDesc*) &TMP257),
((NimStringDesc*) &TMP258),
((NimStringDesc*) &TMP259),
((NimStringDesc*) &TMP260),
((NimStringDesc*) &TMP261),
((NimStringDesc*) &TMP262),
((NimStringDesc*) &TMP263),
((NimStringDesc*) &TMP264),
((NimStringDesc*) &TMP265),
((NimStringDesc*) &TMP266),
((NimStringDesc*) &TMP267),
((NimStringDesc*) &TMP268),
((NimStringDesc*) &TMP269),
((NimStringDesc*) &TMP270),
((NimStringDesc*) &TMP271),
((NimStringDesc*) &TMP272),
((NimStringDesc*) &TMP273),
((NimStringDesc*) &TMP274),
((NimStringDesc*) &TMP275),
((NimStringDesc*) &TMP276),
((NimStringDesc*) &TMP277),
((NimStringDesc*) &TMP278),
((NimStringDesc*) &TMP279),
((NimStringDesc*) &TMP280),
((NimStringDesc*) &TMP281),
((NimStringDesc*) &TMP282),
((NimStringDesc*) &TMP283),
((NimStringDesc*) &TMP284),
((NimStringDesc*) &TMP285),
((NimStringDesc*) &TMP286),
((NimStringDesc*) &TMP287),
((NimStringDesc*) &TMP288),
((NimStringDesc*) &TMP289),
((NimStringDesc*) &TMP290),
((NimStringDesc*) &TMP291),
((NimStringDesc*) &TMP292),
((NimStringDesc*) &TMP293),
((NimStringDesc*) &TMP294),
((NimStringDesc*) &TMP295),
((NimStringDesc*) &TMP296),
((NimStringDesc*) &TMP297),
((NimStringDesc*) &TMP298),
((NimStringDesc*) &TMP299),
((NimStringDesc*) &TMP300),
((NimStringDesc*) &TMP301),
((NimStringDesc*) &TMP302),
((NimStringDesc*) &TMP303),
((NimStringDesc*) &TMP304),
((NimStringDesc*) &TMP305),
((NimStringDesc*) &TMP306),
((NimStringDesc*) &TMP307),
((NimStringDesc*) &TMP308),
((NimStringDesc*) &TMP309),
((NimStringDesc*) &TMP310),
((NimStringDesc*) &TMP311),
((NimStringDesc*) &TMP312),
((NimStringDesc*) &TMP313),
((NimStringDesc*) &TMP314),
((NimStringDesc*) &TMP315),
((NimStringDesc*) &TMP316),
((NimStringDesc*) &TMP317),
((NimStringDesc*) &TMP318),
((NimStringDesc*) &TMP319),
((NimStringDesc*) &TMP320),
((NimStringDesc*) &TMP321),
((NimStringDesc*) &TMP322),
((NimStringDesc*) &TMP323),
((NimStringDesc*) &TMP324),
((NimStringDesc*) &TMP325),
((NimStringDesc*) &TMP326),
((NimStringDesc*) &TMP327),
((NimStringDesc*) &TMP328),
((NimStringDesc*) &TMP329),
((NimStringDesc*) &TMP330),
((NimStringDesc*) &TMP331),
((NimStringDesc*) &TMP332),
((NimStringDesc*) &TMP333),
((NimStringDesc*) &TMP334),
((NimStringDesc*) &TMP335),
((NimStringDesc*) &TMP336),
((NimStringDesc*) &TMP337),
((NimStringDesc*) &TMP338),
((NimStringDesc*) &TMP339),
((NimStringDesc*) &TMP340),
((NimStringDesc*) &TMP341),
((NimStringDesc*) &TMP342),
((NimStringDesc*) &TMP343),
((NimStringDesc*) &TMP344),
((NimStringDesc*) &TMP345),
((NimStringDesc*) &TMP346),
((NimStringDesc*) &TMP347),
((NimStringDesc*) &TMP180),
((NimStringDesc*) &TMP348),
((NimStringDesc*) &TMP349),
((NimStringDesc*) &TMP350),
((NimStringDesc*) &TMP351),
((NimStringDesc*) &TMP352),
((NimStringDesc*) &TMP353),
((NimStringDesc*) &TMP354),
((NimStringDesc*) &TMP355),
((NimStringDesc*) &TMP356),
((NimStringDesc*) &TMP357),
((NimStringDesc*) &TMP358),
((NimStringDesc*) &TMP359),
((NimStringDesc*) &TMP360),
((NimStringDesc*) &TMP361),
((NimStringDesc*) &TMP362),
((NimStringDesc*) &TMP363),
((NimStringDesc*) &TMP364),
((NimStringDesc*) &TMP365),
((NimStringDesc*) &TMP366),
((NimStringDesc*) &TMP367),
((NimStringDesc*) &TMP368),
((NimStringDesc*) &TMP369),
((NimStringDesc*) &TMP370),
((NimStringDesc*) &TMP371),
((NimStringDesc*) &TMP372),
((NimStringDesc*) &TMP373),
((NimStringDesc*) &TMP374),
((NimStringDesc*) &TMP375),
((NimStringDesc*) &TMP376),
((NimStringDesc*) &TMP377),
((NimStringDesc*) &TMP378),
((NimStringDesc*) &TMP379),
((NimStringDesc*) &TMP380),
((NimStringDesc*) &TMP381),
((NimStringDesc*) &TMP382),
((NimStringDesc*) &TMP383),
((NimStringDesc*) &TMP384),
((NimStringDesc*) &TMP385),
((NimStringDesc*) &TMP386),
((NimStringDesc*) &TMP387),
((NimStringDesc*) &TMP388),
((NimStringDesc*) &TMP389),
((NimStringDesc*) &TMP160),
((NimStringDesc*) &TMP159),
((NimStringDesc*) &TMP390),
((NimStringDesc*) &TMP391),
((NimStringDesc*) &TMP392),
((NimStringDesc*) &TMP393),
((NimStringDesc*) &TMP394),
((NimStringDesc*) &TMP395),
((NimStringDesc*) &TMP396),
((NimStringDesc*) &TMP397),
((NimStringDesc*) &TMP398),
((NimStringDesc*) &TMP399),
((NimStringDesc*) &TMP400),
((NimStringDesc*) &TMP401),
((NimStringDesc*) &TMP402),
((NimStringDesc*) &TMP403),
((NimStringDesc*) &TMP404),
((NimStringDesc*) &TMP405),
((NimStringDesc*) &TMP406),
((NimStringDesc*) &TMP407),
((NimStringDesc*) &TMP408),
((NimStringDesc*) &TMP409),
((NimStringDesc*) &TMP410),
((NimStringDesc*) &TMP411),
((NimStringDesc*) &TMP412),
((NimStringDesc*) &TMP160),
((NimStringDesc*) &TMP392),
((NimStringDesc*) &TMP413),
((NimStringDesc*) &TMP414),
((NimStringDesc*) &TMP160),
((NimStringDesc*) &TMP415),
((NimStringDesc*) &TMP160),
((NimStringDesc*) &TMP416),
((NimStringDesc*) &TMP417),
((NimStringDesc*) &TMP169),
((NimStringDesc*) &TMP418),
((NimStringDesc*) &TMP419),
((NimStringDesc*) &TMP420),
((NimStringDesc*) &TMP421),
((NimStringDesc*) &TMP422),
((NimStringDesc*) &TMP160),
((NimStringDesc*) &TMP423),
((NimStringDesc*) &TMP424),
((NimStringDesc*) &TMP425),
((NimStringDesc*) &TMP426),
((NimStringDesc*) &TMP427),
((NimStringDesc*) &TMP428),
((NimStringDesc*) &TMP160),
((NimStringDesc*) &TMP160),
((NimStringDesc*) &TMP147),
((NimStringDesc*) &TMP160),
((NimStringDesc*) &TMP160),
((NimStringDesc*) &TMP160),
((NimStringDesc*) &TMP160),
((NimStringDesc*) &TMP160)}
;
STRING_LITERAL(TMP432, "\012", 1);
STRING_LITERAL(TMP435, "Error: ", 7);
STRING_LITERAL(TMP436, "Warning: ", 9);
STRING_LITERAL(TMP437, "CannotOpenFile", 14);
STRING_LITERAL(TMP438, "OctalEscape", 11);
STRING_LITERAL(TMP439, "XIsNeverRead", 12);
STRING_LITERAL(TMP440, "XmightNotBeenInit", 17);
STRING_LITERAL(TMP441, "Deprecated", 10);
STRING_LITERAL(TMP442, "ConfigDeprecated", 16);
STRING_LITERAL(TMP443, "SmallLshouldNotBeUsed", 21);
STRING_LITERAL(TMP444, "UnknownMagic", 12);
STRING_LITERAL(TMP445, "RedefinitionOfLabel", 19);
STRING_LITERAL(TMP446, "UnknownSubstitutionX", 20);
STRING_LITERAL(TMP447, "LanguageXNotSupported", 21);
STRING_LITERAL(TMP448, "FieldXNotSupported", 18);
STRING_LITERAL(TMP449, "CommentXIgnored", 15);
STRING_LITERAL(TMP450, "NilStmt", 7);
STRING_LITERAL(TMP451, "TypelessParam", 13);
STRING_LITERAL(TMP452, "UseBase", 7);
STRING_LITERAL(TMP453, "WriteToForeignHeap", 18);
STRING_LITERAL(TMP454, "UnsafeCode", 10);
STRING_LITERAL(TMP455, "EachIdentIsTuple", 16);
STRING_LITERAL(TMP456, "ShadowIdent", 11);
STRING_LITERAL(TMP457, "ProveInit", 9);
STRING_LITERAL(TMP458, "ProveField", 10);
STRING_LITERAL(TMP459, "ProveIndex", 10);
STRING_LITERAL(TMP460, "GcUnsafe", 8);
STRING_LITERAL(TMP461, "GcUnsafe2", 9);
STRING_LITERAL(TMP462, "Uninit", 6);
STRING_LITERAL(TMP463, "GcMem", 5);
STRING_LITERAL(TMP464, "Destructor", 10);
STRING_LITERAL(TMP465, "LockLevel", 9);
STRING_LITERAL(TMP466, "ResultShadowed", 14);
STRING_LITERAL(TMP467, "User", 4);
NIM_CONST TY190311 Warningstostr_190309 = {((NimStringDesc*) &TMP437),
((NimStringDesc*) &TMP438),
((NimStringDesc*) &TMP439),
((NimStringDesc*) &TMP440),
((NimStringDesc*) &TMP441),
((NimStringDesc*) &TMP442),
((NimStringDesc*) &TMP443),
((NimStringDesc*) &TMP444),
((NimStringDesc*) &TMP445),
((NimStringDesc*) &TMP446),
((NimStringDesc*) &TMP447),
((NimStringDesc*) &TMP448),
((NimStringDesc*) &TMP449),
((NimStringDesc*) &TMP450),
((NimStringDesc*) &TMP451),
((NimStringDesc*) &TMP452),
((NimStringDesc*) &TMP453),
((NimStringDesc*) &TMP454),
((NimStringDesc*) &TMP455),
((NimStringDesc*) &TMP456),
((NimStringDesc*) &TMP457),
((NimStringDesc*) &TMP458),
((NimStringDesc*) &TMP459),
((NimStringDesc*) &TMP460),
((NimStringDesc*) &TMP461),
((NimStringDesc*) &TMP462),
((NimStringDesc*) &TMP463),
((NimStringDesc*) &TMP464),
((NimStringDesc*) &TMP465),
((NimStringDesc*) &TMP466),
((NimStringDesc*) &TMP467)}
;
STRING_LITERAL(TMP468, "Hint: ", 6);
STRING_LITERAL(TMP469, "Success", 7);
STRING_LITERAL(TMP470, "SuccessX", 8);
STRING_LITERAL(TMP471, "LineTooLong", 11);
STRING_LITERAL(TMP472, "XDeclaredButNotUsed", 19);
STRING_LITERAL(TMP473, "ConvToBaseNotNeeded", 19);
STRING_LITERAL(TMP474, "ConvFromXtoItselfNotNeeded", 26);
STRING_LITERAL(TMP475, "ExprAlwaysX", 11);
STRING_LITERAL(TMP476, "QuitCalled", 10);
STRING_LITERAL(TMP477, "Processing", 10);
STRING_LITERAL(TMP478, "CodeBegin", 9);
STRING_LITERAL(TMP479, "CodeEnd", 7);
STRING_LITERAL(TMP480, "Conf", 4);
STRING_LITERAL(TMP481, "Path", 4);
STRING_LITERAL(TMP482, "CondTrue", 8);
STRING_LITERAL(TMP483, "Name", 4);
STRING_LITERAL(TMP484, "Pattern", 7);
STRING_LITERAL(TMP485, "Exec", 4);
STRING_LITERAL(TMP486, "Link", 4);
STRING_LITERAL(TMP487, "Dependency", 10);
STRING_LITERAL(TMP488, "Source", 6);
STRING_LITERAL(TMP489, "StackTrace", 10);
STRING_LITERAL(TMP490, "GCStats", 7);
NIM_CONST TY190317 Hintstostr_190314 = {((NimStringDesc*) &TMP469),
((NimStringDesc*) &TMP470),
((NimStringDesc*) &TMP471),
((NimStringDesc*) &TMP472),
((NimStringDesc*) &TMP473),
((NimStringDesc*) &TMP474),
((NimStringDesc*) &TMP475),
((NimStringDesc*) &TMP476),
((NimStringDesc*) &TMP477),
((NimStringDesc*) &TMP478),
((NimStringDesc*) &TMP479),
((NimStringDesc*) &TMP480),
((NimStringDesc*) &TMP481),
((NimStringDesc*) &TMP482),
((NimStringDesc*) &TMP483),
((NimStringDesc*) &TMP484),
((NimStringDesc*) &TMP485),
((NimStringDesc*) &TMP486),
((NimStringDesc*) &TMP487),
((NimStringDesc*) &TMP488),
((NimStringDesc*) &TMP489),
((NimStringDesc*) &TMP490),
((NimStringDesc*) &TMP467)}
;
STRING_LITERAL(TMP491, " [$1]", 5);
STRING_LITERAL(TMP494, "No stack traceback available\012To create a stacktrace, rerun comp"
"ilation with ./koch temp ", 88);
STRING_LITERAL(TMP495, " <file>", 7);
STRING_LITERAL(TMP500, "ropes: invalid format string: ", 30);
STRING_LITERAL(TMP1048, "  ", 2);
STRING_LITERAL(TMP1066, "compiler/msgs.nim", 17);
NIM_CONST TY91159 TMP1065 = {((NimStringDesc*) &TMP1066),
((NI) 1008)}
;
STRING_LITERAL(TMP1897, "Warnings:", 9);
STRING_LITERAL(TMP1898, "  [$1] $2", 9);
STRING_LITERAL(TMP1899, "x", 1);
STRING_LITERAL(TMP1900, " ", 1);
STRING_LITERAL(TMP1959, "Hints:", 6);
NIM_CONST TY190379 Notesverbosity_190377 = {IL64(9130889969139711),
IL64(9412918996631551),
IL64(15762598695796735),
IL64(18014398509481983)}
;
STRING_LITERAL(TMP2772, "suggest done", 12);
STRING_LITERAL(TMP3232, "(", 1);
STRING_LITERAL(TMP3233, ",", 1);
STRING_LITERAL(TMP3234, ")", 1);
NIM_CONST TY91159 TMP3998 = {((NimStringDesc*) &TMP1066),
((NI) 1015)}
;
Table190452 filenametoindextbl_190614;
extern TNimType NTI190452; /* Table */
TY190615* fileinfos_190632;
TNimType NTI190350; /* TFileInfo */
extern TNimType NTI149; /* string */
extern TNimType NTI176007; /* Rope */
TNimType NTI190365; /* seq[Rope] */
TNimType NTI190615; /* seq[TFileInfo] */
extern Gcheap51218 gch_51259;
NI32 systemfileidx_190633;
extern NimStringDesc* tnl_174654;
extern NU32 gglobaloptions_167132;
Tlineinfo190352 gcmdlineinfo_191321;
Tlineinfo190352 gcodegenlineinfo_191359;
NU64 gnotes_191395;
NI gerrorcounter_191396;
NI ghintcounter_191397;
NI gwarncounter_191398;
NI gerrormax_191399;
TY191417* msgcontext_191434;
TNimType NTI190352; /* TLineInfo */
extern TNimType NTI112; /* int16 */
extern TNimType NTI114; /* int32 */
TNimType NTI191417; /* seq[TLineInfo] */
Tlineinfo190352 lasterror_191435;
NU8 erroroutputs_191437;
TY191438 writelnhook_191441;
Tlineinfo190352 gtrackpos_191901;
extern TY176023 errorhandler_176028;
extern NU8 gcmd_167134;
extern NIM_BOOL glistfullpaths_167146;
extern NU32 goptions_167130;
extern NimStringDesc* command_167240;
extern NI8 gexitcode_167133;
extern TNimType NTI4049; /* ValueError */
TNimType NTI190358; /* ERecoverableError */
TNimType NTI191373; /* ref ERecoverableError */
extern TSafePoint* exchandler_21043;
extern TNimType NTI4031; /* IOError */
extern Exception* currexception_21045;
TNimType NTI190005; /* TMsgKind */
TNimType NTI190346; /* TNoteKind */
TNimType NTI190348; /* TNoteKinds */
extern TNimType NTI4027; /* Exception */
TNimType NTI190360; /* ESuggestDone */
TNimType NTI191512; /* ref ESuggestDone */
N_NIMCALL(void, TMP144)(void* p, NI op) {
	TY190365* a;
	NI LOC1;
	a = (TY190365*)p;
	LOC1 = 0;
	for (LOC1 = 0; LOC1 < a->Sup.len; LOC1++) {
	nimGCvisit((void*)a->data[LOC1], op);
	}
}
N_NIMCALL(void, TMP145)(void* p, NI op) {
	TY190615* a;
	NI LOC1;
	a = (TY190615*)p;
	LOC1 = 0;
	for (LOC1 = 0; LOC1 < a->Sup.len; LOC1++) {
	nimGCvisit((void*)a->data[LOC1].fullpath, op);
	nimGCvisit((void*)a->data[LOC1].projpath, op);
	nimGCvisit((void*)a->data[LOC1].shortname, op);
	nimGCvisit((void*)a->data[LOC1].quotedname, op);
	nimGCvisit((void*)a->data[LOC1].lines, op);
	nimGCvisit((void*)a->data[LOC1].dirtyfile, op);
	}
}

static N_INLINE(Cell49146*, usrtocell_52846)(void* usr) {
	Cell49146* result;
	result = 0;
	result = ((Cell49146*) ((NI)((NU64)(((NI) (usr))) - (NU64)(((NI)sizeof(Cell49146))))));
	return result;
}

static N_INLINE(void, rtladdzct_54404)(Cell49146* c) {
	addzct_52817((&gch_51259.zct), c);
}

static N_INLINE(void, nimGCunrefNoCycle)(void* p) {
	Cell49146* c;
	c = usrtocell_52846(p);
	{
		(*c).refcount -= ((NI) 8);
		if (!((NU64)((*c).refcount) < (NU64)(((NI) 8)))) goto LA3;
		rtladdzct_54404(c);
	}
	LA3: ;
}

static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src) {
	memcpy(((NCSTRING) ((&(*dest).data[((*dest).Sup.len)- 0]))), ((NCSTRING) ((*src).data)), (NI)((*src).Sup.len + ((NI) 1)));
	(*dest).Sup.len += (*src).Sup.len;
}

static N_INLINE(void, appendChar)(NimStringDesc* dest, NIM_CHAR c) {
	(*dest).data[((*dest).Sup.len)- 0] = c;
	(*dest).data[((NI)((*dest).Sup.len + ((NI) 1)))- 0] = 0;
	(*dest).Sup.len += ((NI) 1);
}

N_NIMCALL(NimStringDesc*, tocchar_190639)(NIM_CHAR c) {
	NimStringDesc* result;
	result = 0;
	switch (((NU8)(c))) {
	case 0 ... 31:
	case 128 ... 255:
	{
		NimStringDesc* LOC2;
		NimStringDesc* LOC3;
		LOC2 = 0;
		LOC3 = 0;
		LOC3 = nsuToOctal(c);
		LOC2 = rawNewString(LOC3->Sup.len + 1);
appendChar(LOC2, 92);
appendString(LOC2, LOC3);
		result = LOC2;
	}
	break;
	case 39:
	case 34:
	case 92:
	{
		NimStringDesc* LOC5;
		LOC5 = 0;
		LOC5 = rawNewString(2);
appendChar(LOC5, 92);
appendChar(LOC5, c);
		result = LOC5;
	}
	break;
	default:
	{
		result = nimCharToStr(c);
	}
	break;
	}
	return result;
}

N_NIMCALL(Ropeobj176009*, makecstring_190649)(NimStringDesc* s) {
	Ropeobj176009* result;
	NimStringDesc* res;
	Ropeobj176009* LOC9;
	result = 0;
	result = NIM_NIL;
	res = rawNewString(((NI) ((NI)(((NI) (((NF)(((double) ((s ? s->Sup.len : 0)))) * (NF)(1.1000000000000001e+00)))) + ((NI) 1)))));
	res = resizeString(res, 1);
appendString(res, ((NimStringDesc*) &TMP148));
	{
		NI i_190667;
		NI HEX3Atmp_190672;
		NI res_190675;
		i_190667 = 0;
		HEX3Atmp_190672 = 0;
		HEX3Atmp_190672 = (NI)((s ? s->Sup.len : 0) - ((NI) 1));
		res_190675 = ((NI) 0);
		{
			while (1) {
				NimStringDesc* LOC8;
				if (!(res_190675 <= HEX3Atmp_190672)) goto LA3;
				i_190667 = res_190675;
				{
					if (!(((NI) ((NI)((NI)(i_190667 + ((NI) 1)) % ((NI) 64)))) == ((NI) 0))) goto LA6;
					res = addChar(res, 34);
					res = resizeString(res, tnl_174654->Sup.len + 0);
appendString(res, tnl_174654);
					res = addChar(res, 34);
				}
				LA6: ;
				LOC8 = 0;
				LOC8 = tocchar_190639(s->data[i_190667]);
				res = resizeString(res, LOC8->Sup.len + 0);
appendString(res, LOC8);
				res_190675 += ((NI) 1);
			} LA3: ;
		}
	}
	res = addChar(res, 34);
	LOC9 = 0;
	LOC9 = rope_176322(res);
	add_176534(&result, LOC9);
	return result;
}

N_NIMCALL(void, newfileinfo_190694)(NimStringDesc* fullpath, NimStringDesc* projpath, Tfileinfo190350* Result) {
	NimStringDesc* filename;
	unsureAsgnRef((void**) (&(*Result).fullpath), copyString(fullpath));
	unsureAsgnRef((void**) (&(*Result).projpath), copyString(projpath));
	filename = nosextractFilename(projpath);
	unsureAsgnRef((void**) (&(*Result).shortname), noschangeFileExt(filename, ((NimStringDesc*) &TMP147)));
	unsureAsgnRef((void**) (&(*Result).quotedname), makecstring_190649(filename));
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = ((gglobaloptions_167132 &(1<<((((NU8) 28))&31)))!=0);
		if (LOC3) goto LA4;
		LOC3 = NIM_TRUE;
		LA4: ;
		if (!LOC3) goto LA5;
		unsureAsgnRef((void**) (&(*Result).lines), (TY190365*) newSeq((&NTI190365), 0));
	}
	LA5: ;
}

N_NIMCALL(Tlineinfo190352, newlineinfo_191266)(NI32 fileinfoidx, NI line, NI col) {
	Tlineinfo190352 result;
	memset((void*)(&result), 0, sizeof(result));
	result.fileindex = fileinfoidx;
	result.line = ((NI16) (line));
	result.col = ((NI16) (col));
	return result;
}
N_NIMCALL(void, TMP152)(void* p, NI op) {
	TY191417* a;
	NI LOC1;
	a = (TY191417*)p;
	LOC1 = 0;
	for (LOC1 = 0; LOC1 < a->Sup.len; LOC1++) {
	}
}

N_NIMCALL(Tlineinfo190352, unknownlineinfo_191408)(void) {
	Tlineinfo190352 result;
	memset((void*)(&result), 0, sizeof(result));
	result.line = ((NI16) -1);
	result.col = ((NI16) -1);
	result.fileindex = ((NI32) -1);
	return result;
}

N_NIMCALL(NIM_BOOL, HEX3DHEX3D_193255)(Tlineinfo190352 a, Tlineinfo190352 b) {
	NIM_BOOL result;
	NIM_BOOL LOC1;
	result = 0;
	LOC1 = 0;
	LOC1 = (a.line == b.line);
	if (!(LOC1)) goto LA2;
	LOC1 = (a.fileindex == b.fileindex);
	LA2: ;
	result = LOC1;
	return result;
}

N_NIMCALL(NimStringDesc*, tomsgfilename_191829)(Tlineinfo190352 info) {
	NimStringDesc* result;
	result = 0;
	{
		if (!(info.fileindex < ((NI32) 0))) goto LA3;
		result = copyString(((NimStringDesc*) &TMP155));
	}
	goto LA1;
	LA3: ;
	{
		if (!glistfullpaths_167146) goto LA6;
		result = copyString(fileinfos_190632->data[info.fileindex].fullpath);
	}
	goto LA1;
	LA6: ;
	{
		result = copyString(fileinfos_190632->data[info.fileindex].projpath);
	}
	LA1: ;
	return result;
}

N_NIMCALL(NimStringDesc*, coordtostr_192396)(NI coord) {
	NimStringDesc* result;
	result = 0;
	{
		if (!(coord == ((NI) -1))) goto LA3;
		result = copyString(((NimStringDesc*) &TMP155));
	}
	goto LA1;
	LA3: ;
	{
		result = nimIntToStr(coord);
	}
	LA1: ;
	return result;
}

N_NIMCALL(NimStringDesc*, msgkindtostring_192406)(NU16 kind) {
	NimStringDesc* result;
	result = 0;
	result = copyString(Msgkindtostr_190300[(kind)- 0]);
	return result;
}

N_NIMCALL(NimStringDesc*, getmessagestr_192416)(NU16 msg, NimStringDesc* arg) {
	NimStringDesc* result;
	NimStringDesc* LOC1;
	TY192421 LOC2;
	result = 0;
	LOC1 = 0;
	LOC1 = msgkindtostring_192406(msg);
	memset((void*)LOC2, 0, sizeof(LOC2));
	LOC2[0] = copyString(arg);
	result = nsuFormatOpenArray(LOC1, LOC2, 1);
	return result;
}

static N_INLINE(void, writeline_168405)(FILE* f, NimStringDesc** x, NI xLen0) {
	{
		NimStringDesc* i_168421;
		NI i_168429;
		i_168421 = 0;
		i_168429 = ((NI) 0);
		{
			while (1) {
				if (!(i_168429 < xLen0)) goto LA3;
				i_168421 = x[i_168429];
				write_17095(f, i_168421);
				i_168429 += ((NI) 1);
			} LA3: ;
		}
	}
	write_17095(f, ((NimStringDesc*) &TMP432));
}

N_NIMCALL(void, writecontext_193266)(Tlineinfo190352 lastinfo) {
	Tlineinfo190352 info;
	info = lastinfo;
	{
		NI i_193290;
		NI HEX3Atmp_193606;
		NI res_193609;
		i_193290 = 0;
		HEX3Atmp_193606 = 0;
		HEX3Atmp_193606 = (NI)((msgcontext_191434 ? msgcontext_191434->Sup.len : 0) - ((NI) 1));
		res_193609 = ((NI) 0);
		{
			while (1) {
				if (!(res_193609 <= HEX3Atmp_193606)) goto LA3;
				i_193290 = res_193609;
				{
					NIM_BOOL LOC6;
					NIM_BOOL LOC7;
					NIM_BOOL LOC9;
					LOC6 = 0;
					LOC7 = 0;
					LOC7 = HEX3DHEX3D_193255(msgcontext_191434->data[i_193290], lastinfo);
					LOC6 = !(LOC7);
					if (!(LOC6)) goto LA8;
					LOC9 = 0;
					LOC9 = HEX3DHEX3D_193255(msgcontext_191434->data[i_193290], info);
					LOC6 = !(LOC9);
					LA8: ;
					if (!LOC6) goto LA10;
					{
						NimStringDesc* s_193309;
						if (!!(writelnhook_191441.ClPrc == 0)) goto LA14;
						s_193309 = copyString(((NimStringDesc*) &TMP147));
						{
							NimStringDesc* arg_193311;
							NI i_193605;
							arg_193311 = 0;
							i_193605 = ((NI) 0);
							{
								while (1) {
									TY193306 LOC19;
									TY193293 LOC20;
									if (!(i_193605 < ((NI) 2))) goto LA18;
									memset((void*)LOC19, 0, sizeof(LOC19));
									memset((void*)LOC20, 0, sizeof(LOC20));
									LOC20[0] = tomsgfilename_191829(msgcontext_191434->data[i_193290]);
									LOC20[1] = coordtostr_192396(((NI) (msgcontext_191434->data[i_193290].line)));
									LOC20[2] = coordtostr_192396(((NI) ((NI16)(msgcontext_191434->data[i_193290].col + ((NI16) 1)))));
									LOC19[0] = nsuFormatOpenArray(((NimStringDesc*) &TMP154), LOC20, 3);
									LOC19[1] = getmessagestr_192416(((NU16) 189), ((NimStringDesc*) &TMP147));
									arg_193311 = LOC19[(i_193605)- 0];
									s_193309 = resizeString(s_193309, arg_193311->Sup.len + 0);
appendString(s_193309, arg_193311);
									i_193605 += ((NI) 1);
								} LA18: ;
							}
						}
						writelnhook_191441.ClEnv? writelnhook_191441.ClPrc(s_193309, writelnhook_191441.ClEnv):((TMP429)(writelnhook_191441.ClPrc))(s_193309);
					}
					goto LA12;
					LA14: ;
					{
						if (!((gglobaloptions_167132 &(1<<((((NU8) 23))&31)))!=0)) goto LA22;
						{
							TY193306 LOC28;
							TY193293 LOC29;
							if (!((erroroutputs_191437 &(1<<((((NU8) 0))&7)))!=0)) goto LA26;
							memset((void*)LOC28, 0, sizeof(LOC28));
							memset((void*)LOC29, 0, sizeof(LOC29));
							LOC29[0] = tomsgfilename_191829(msgcontext_191434->data[i_193290]);
							LOC29[1] = coordtostr_192396(((NI) (msgcontext_191434->data[i_193290].line)));
							LOC29[2] = coordtostr_192396(((NI) ((NI16)(msgcontext_191434->data[i_193290].col + ((NI16) 1)))));
							LOC28[0] = nsuFormatOpenArray(((NimStringDesc*) &TMP154), LOC29, 3);
							LOC28[1] = getmessagestr_192416(((NU16) 189), ((NimStringDesc*) &TMP147));
							writeline_168405(stdout, LOC28, 2);
							fflush(stdout);
						}
						LA26: ;
					}
					goto LA12;
					LA22: ;
					{
						{
							if (!((erroroutputs_191437 &(1<<((((NU8) 1))&7)))!=0)) goto LA33;
							{
								TY193293 LOC39;
								NimStringDesc* LOC40;
								NimStringDesc* LOC41;
								if (!((gglobaloptions_167132 &(1<<((((NU8) 21))&31)))!=0)) goto LA37;
								setstyle_187604(stderr, 1);
								memset((void*)LOC39, 0, sizeof(LOC39));
								LOC39[0] = tomsgfilename_191829(msgcontext_191434->data[i_193290]);
								LOC39[1] = coordtostr_192396(((NI) (msgcontext_191434->data[i_193290].line)));
								LOC39[2] = coordtostr_192396(((NI) ((NI16)(msgcontext_191434->data[i_193290].col + ((NI16) 1)))));
								LOC40 = 0;
								LOC40 = nsuFormatOpenArray(((NimStringDesc*) &TMP154), LOC39, 3);
								write_17095(stderr, LOC40);
								resetattributes_187209(stderr);
								LOC41 = 0;
								LOC41 = getmessagestr_192416(((NU16) 189), ((NimStringDesc*) &TMP147));
								write_17095(stderr, LOC41);
								write_17095(stderr, ((NimStringDesc*) &TMP432));
								resetattributes_187209(stderr);
							}
							goto LA35;
							LA37: ;
							{
								TY193306 LOC43;
								TY193293 LOC44;
								memset((void*)LOC43, 0, sizeof(LOC43));
								memset((void*)LOC44, 0, sizeof(LOC44));
								LOC44[0] = tomsgfilename_191829(msgcontext_191434->data[i_193290]);
								LOC44[1] = coordtostr_192396(((NI) (msgcontext_191434->data[i_193290].line)));
								LOC44[2] = coordtostr_192396(((NI) ((NI16)(msgcontext_191434->data[i_193290].col + ((NI16) 1)))));
								LOC43[0] = nsuFormatOpenArray(((NimStringDesc*) &TMP154), LOC44, 3);
								LOC43[1] = getmessagestr_192416(((NU16) 189), ((NimStringDesc*) &TMP147));
								writeline_168405(stderr, LOC43, 2);
							}
							LA35: ;
						}
						LA33: ;
					}
					LA12: ;
				}
				LA10: ;
				info = msgcontext_191434->data[i_193290];
				res_193609 += ((NI) 1);
			} LA3: ;
		}
	}
}

N_NIMCALL(NIM_BOOL, ignoremsgbecauseofidetools_193637)(NU16 msg) {
	NIM_BOOL result;
	NIM_BOOL LOC1;
	NIM_BOOL LOC2;
	result = 0;
	LOC1 = 0;
	LOC2 = 0;
	LOC2 = (((NU16) 4) <= msg);
	if (!(LOC2)) goto LA3;
	LOC2 = (gcmd_167134 == ((NU8) 14));
	LA3: ;
	LOC1 = LOC2;
	if (!(LOC1)) goto LA4;
	LOC1 = !(((gglobaloptions_167132 &(1<<((((NU8) 29))&31)))!=0));
	LA4: ;
	result = LOC1;
	return result;
}
N_NIMCALL(void, TMP499)(void* p, NI op) {
	Erecoverableerror190358* a;
	a = (Erecoverableerror190358*)p;
	nimGCvisit((void*)(*a).Sup.Sup.parent, op);
	nimGCvisit((void*)(*a).Sup.Sup.message, op);
	nimGCvisit((void*)(*a).Sup.Sup.trace, op);
}

N_NOINLINE(void, raiserecoverableerror_191366)(NimStringDesc* msg) {
	Erecoverableerror190358* e_191372;
	NimStringDesc* LOC1;
	e_191372 = 0;
	e_191372 = (Erecoverableerror190358*) newObj((&NTI191373), sizeof(Erecoverableerror190358));
	(*e_191372).Sup.Sup.Sup.m_type = (&NTI190358);
	LOC1 = 0;
	LOC1 = (*e_191372).Sup.Sup.message; (*e_191372).Sup.Sup.message = copyStringRC1(msg);
	if (LOC1) nimGCunrefNoCycle(LOC1);
	raiseException((Exception*)e_191372, "ERecoverableError");
}

N_NIMCALL(void, handleerror_192437)(NU16 msg, NU8 eh, NimStringDesc* s_192441) {
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = (((NU16) 0) <= msg);
		if (!(LOC3)) goto LA4;
		LOC3 = (msg <= ((NU16) 2));
		LA4: ;
		if (!LOC3) goto LA5;
		{
			NIM_BOOL LOC9;
			NIM_BOOL LOC10;
			LOC9 = 0;
			LOC10 = 0;
			LOC10 = NIM_FALSE;
			if (LOC10) goto LA11;
			LOC10 = (msg == ((NU16) 2));
			LA11: ;
			LOC9 = LOC10;
			if (LOC9) goto LA12;
			LOC9 = ((gnotes_191395 &(IL64(1)<<(((((NU16) 288)- 237))&IL64(63))))!=0);
			LA12: ;
			if (!LOC9) goto LA13;
			{
				NIM_BOOL LOC17;
				LOC17 = 0;
				LOC17 = stacktraceavailable_21930();
				if (!(LOC17)) goto LA18;
				LOC17 = writelnhook_191441.ClPrc == 0;
				LA18: ;
				if (!LOC17) goto LA19;
				writestacktrace_20407();
			}
			goto LA15;
			LA19: ;
			{
				{
					NimStringDesc* s_192512;
					if (!!(writelnhook_191441.ClPrc == 0)) goto LA24;
					s_192512 = copyString(((NimStringDesc*) &TMP147));
					{
						NimStringDesc* arg_192514;
						NI i_193213;
						arg_192514 = 0;
						i_193213 = ((NI) 0);
						{
							while (1) {
								TY192421 LOC29;
								NimStringDesc* LOC30;
								if (!(i_193213 < ((NI) 1))) goto LA28;
								memset((void*)LOC29, 0, sizeof(LOC29));
								LOC30 = 0;
								LOC30 = rawNewString(command_167240->Sup.len + 95);
appendString(LOC30, ((NimStringDesc*) &TMP494));
appendString(LOC30, command_167240);
appendString(LOC30, ((NimStringDesc*) &TMP495));
								LOC29[0] = LOC30;
								arg_192514 = LOC29[(i_193213)- 0];
								s_192512 = resizeString(s_192512, arg_192514->Sup.len + 0);
appendString(s_192512, arg_192514);
								i_193213 += ((NI) 1);
							} LA28: ;
						}
					}
					writelnhook_191441.ClEnv? writelnhook_191441.ClPrc(s_192512, writelnhook_191441.ClEnv):((TMP496)(writelnhook_191441.ClPrc))(s_192512);
				}
				goto LA22;
				LA24: ;
				{
					if (!((gglobaloptions_167132 &(1<<((((NU8) 23))&31)))!=0)) goto LA32;
					{
						TY192421 LOC38;
						NimStringDesc* LOC39;
						if (!((erroroutputs_191437 &(1<<((((NU8) 0))&7)))!=0)) goto LA36;
						memset((void*)LOC38, 0, sizeof(LOC38));
						LOC39 = 0;
						LOC39 = rawNewString(command_167240->Sup.len + 95);
appendString(LOC39, ((NimStringDesc*) &TMP494));
appendString(LOC39, command_167240);
appendString(LOC39, ((NimStringDesc*) &TMP495));
						LOC38[0] = LOC39;
						writeline_168405(stdout, LOC38, 1);
						fflush(stdout);
					}
					LA36: ;
				}
				goto LA22;
				LA32: ;
				{
					{
						if (!((erroroutputs_191437 &(1<<((((NU8) 1))&7)))!=0)) goto LA43;
						{
							NimStringDesc* LOC49;
							if (!((gglobaloptions_167132 &(1<<((((NU8) 21))&31)))!=0)) goto LA47;
							setforegroundcolor_188057(stderr, ((NU8) 31), NIM_FALSE);
							LOC49 = 0;
							LOC49 = rawNewString(command_167240->Sup.len + 95);
appendString(LOC49, ((NimStringDesc*) &TMP494));
appendString(LOC49, command_167240);
appendString(LOC49, ((NimStringDesc*) &TMP495));
							write_17095(stderr, LOC49);
							write_17095(stderr, ((NimStringDesc*) &TMP432));
							resetattributes_187209(stderr);
						}
						goto LA45;
						LA47: ;
						{
							TY192421 LOC51;
							NimStringDesc* LOC52;
							memset((void*)LOC51, 0, sizeof(LOC51));
							LOC52 = 0;
							LOC52 = rawNewString(command_167240->Sup.len + 95);
appendString(LOC52, ((NimStringDesc*) &TMP494));
appendString(LOC52, command_167240);
appendString(LOC52, ((NimStringDesc*) &TMP495));
							LOC51[0] = LOC52;
							writeline_168405(stderr, LOC51, 1);
						}
						LA45: ;
					}
					LA43: ;
				}
				LA22: ;
			}
			LA15: ;
		}
		LA13: ;
		exit(((NI) 1));
	}
	LA5: ;
	{
		NIM_BOOL LOC55;
		LOC55 = 0;
		LOC55 = (((NU16) 0) <= msg);
		if (!(LOC55)) goto LA56;
		LOC55 = (msg <= ((NU16) 236));
		LA56: ;
		if (!LOC55) goto LA57;
		gerrorcounter_191396 += ((NI) 1);
		gexitcode_167133 = ((NI8) 1);
		{
			if (!(gerrormax_191399 <= gerrorcounter_191396)) goto LA61;
			{
				NIM_BOOL LOC65;
				NIM_BOOL LOC66;
				LOC65 = 0;
				LOC66 = 0;
				LOC66 = NIM_FALSE;
				if (LOC66) goto LA67;
				LOC66 = (msg == ((NU16) 2));
				LA67: ;
				LOC65 = LOC66;
				if (LOC65) goto LA68;
				LOC65 = ((gnotes_191395 &(IL64(1)<<(((((NU16) 288)- 237))&IL64(63))))!=0);
				LA68: ;
				if (!LOC65) goto LA69;
				{
					NIM_BOOL LOC73;
					LOC73 = 0;
					LOC73 = stacktraceavailable_21930();
					if (!(LOC73)) goto LA74;
					LOC73 = writelnhook_191441.ClPrc == 0;
					LA74: ;
					if (!LOC73) goto LA75;
					writestacktrace_20407();
				}
				goto LA71;
				LA75: ;
				{
					{
						NimStringDesc* s_192869;
						if (!!(writelnhook_191441.ClPrc == 0)) goto LA80;
						s_192869 = copyString(((NimStringDesc*) &TMP147));
						{
							NimStringDesc* arg_192871;
							NI i_193217;
							arg_192871 = 0;
							i_193217 = ((NI) 0);
							{
								while (1) {
									TY192421 LOC85;
									NimStringDesc* LOC86;
									if (!(i_193217 < ((NI) 1))) goto LA84;
									memset((void*)LOC85, 0, sizeof(LOC85));
									LOC86 = 0;
									LOC86 = rawNewString(command_167240->Sup.len + 95);
appendString(LOC86, ((NimStringDesc*) &TMP494));
appendString(LOC86, command_167240);
appendString(LOC86, ((NimStringDesc*) &TMP495));
									LOC85[0] = LOC86;
									arg_192871 = LOC85[(i_193217)- 0];
									s_192869 = resizeString(s_192869, arg_192871->Sup.len + 0);
appendString(s_192869, arg_192871);
									i_193217 += ((NI) 1);
								} LA84: ;
							}
						}
						writelnhook_191441.ClEnv? writelnhook_191441.ClPrc(s_192869, writelnhook_191441.ClEnv):((TMP497)(writelnhook_191441.ClPrc))(s_192869);
					}
					goto LA78;
					LA80: ;
					{
						if (!((gglobaloptions_167132 &(1<<((((NU8) 23))&31)))!=0)) goto LA88;
						{
							TY192421 LOC94;
							NimStringDesc* LOC95;
							if (!((erroroutputs_191437 &(1<<((((NU8) 0))&7)))!=0)) goto LA92;
							memset((void*)LOC94, 0, sizeof(LOC94));
							LOC95 = 0;
							LOC95 = rawNewString(command_167240->Sup.len + 95);
appendString(LOC95, ((NimStringDesc*) &TMP494));
appendString(LOC95, command_167240);
appendString(LOC95, ((NimStringDesc*) &TMP495));
							LOC94[0] = LOC95;
							writeline_168405(stdout, LOC94, 1);
							fflush(stdout);
						}
						LA92: ;
					}
					goto LA78;
					LA88: ;
					{
						{
							if (!((erroroutputs_191437 &(1<<((((NU8) 1))&7)))!=0)) goto LA99;
							{
								NimStringDesc* LOC105;
								if (!((gglobaloptions_167132 &(1<<((((NU8) 21))&31)))!=0)) goto LA103;
								setforegroundcolor_188057(stderr, ((NU8) 31), NIM_FALSE);
								LOC105 = 0;
								LOC105 = rawNewString(command_167240->Sup.len + 95);
appendString(LOC105, ((NimStringDesc*) &TMP494));
appendString(LOC105, command_167240);
appendString(LOC105, ((NimStringDesc*) &TMP495));
								write_17095(stderr, LOC105);
								write_17095(stderr, ((NimStringDesc*) &TMP432));
								resetattributes_187209(stderr);
							}
							goto LA101;
							LA103: ;
							{
								TY192421 LOC107;
								NimStringDesc* LOC108;
								memset((void*)LOC107, 0, sizeof(LOC107));
								LOC108 = 0;
								LOC108 = rawNewString(command_167240->Sup.len + 95);
appendString(LOC108, ((NimStringDesc*) &TMP494));
appendString(LOC108, command_167240);
appendString(LOC108, ((NimStringDesc*) &TMP495));
								LOC107[0] = LOC108;
								writeline_168405(stderr, LOC107, 1);
							}
							LA101: ;
						}
						LA99: ;
					}
					LA78: ;
				}
				LA71: ;
			}
			LA69: ;
			exit(((NI) 1));
		}
		goto LA59;
		LA61: ;
		{
			NIM_BOOL LOC110;
			LOC110 = 0;
			LOC110 = (eh == ((NU8) 1));
			if (!(LOC110)) goto LA111;
			LOC110 = !((gcmd_167134 == ((NU8) 14)));
			LA111: ;
			if (!LOC110) goto LA112;
			{
				NIM_BOOL LOC116;
				NIM_BOOL LOC117;
				LOC116 = 0;
				LOC117 = 0;
				LOC117 = NIM_FALSE;
				if (LOC117) goto LA118;
				LOC117 = (msg == ((NU16) 2));
				LA118: ;
				LOC116 = LOC117;
				if (LOC116) goto LA119;
				LOC116 = ((gnotes_191395 &(IL64(1)<<(((((NU16) 288)- 237))&IL64(63))))!=0);
				LA119: ;
				if (!LOC116) goto LA120;
				{
					NIM_BOOL LOC124;
					LOC124 = 0;
					LOC124 = stacktraceavailable_21930();
					if (!(LOC124)) goto LA125;
					LOC124 = writelnhook_191441.ClPrc == 0;
					LA125: ;
					if (!LOC124) goto LA126;
					writestacktrace_20407();
				}
				goto LA122;
				LA126: ;
				{
					{
						NimStringDesc* s_193060;
						if (!!(writelnhook_191441.ClPrc == 0)) goto LA131;
						s_193060 = copyString(((NimStringDesc*) &TMP147));
						{
							NimStringDesc* arg_193062;
							NI i_193221;
							arg_193062 = 0;
							i_193221 = ((NI) 0);
							{
								while (1) {
									TY192421 LOC136;
									NimStringDesc* LOC137;
									if (!(i_193221 < ((NI) 1))) goto LA135;
									memset((void*)LOC136, 0, sizeof(LOC136));
									LOC137 = 0;
									LOC137 = rawNewString(command_167240->Sup.len + 95);
appendString(LOC137, ((NimStringDesc*) &TMP494));
appendString(LOC137, command_167240);
appendString(LOC137, ((NimStringDesc*) &TMP495));
									LOC136[0] = LOC137;
									arg_193062 = LOC136[(i_193221)- 0];
									s_193060 = resizeString(s_193060, arg_193062->Sup.len + 0);
appendString(s_193060, arg_193062);
									i_193221 += ((NI) 1);
								} LA135: ;
							}
						}
						writelnhook_191441.ClEnv? writelnhook_191441.ClPrc(s_193060, writelnhook_191441.ClEnv):((TMP498)(writelnhook_191441.ClPrc))(s_193060);
					}
					goto LA129;
					LA131: ;
					{
						if (!((gglobaloptions_167132 &(1<<((((NU8) 23))&31)))!=0)) goto LA139;
						{
							TY192421 LOC145;
							NimStringDesc* LOC146;
							if (!((erroroutputs_191437 &(1<<((((NU8) 0))&7)))!=0)) goto LA143;
							memset((void*)LOC145, 0, sizeof(LOC145));
							LOC146 = 0;
							LOC146 = rawNewString(command_167240->Sup.len + 95);
appendString(LOC146, ((NimStringDesc*) &TMP494));
appendString(LOC146, command_167240);
appendString(LOC146, ((NimStringDesc*) &TMP495));
							LOC145[0] = LOC146;
							writeline_168405(stdout, LOC145, 1);
							fflush(stdout);
						}
						LA143: ;
					}
					goto LA129;
					LA139: ;
					{
						{
							if (!((erroroutputs_191437 &(1<<((((NU8) 1))&7)))!=0)) goto LA150;
							{
								NimStringDesc* LOC156;
								if (!((gglobaloptions_167132 &(1<<((((NU8) 21))&31)))!=0)) goto LA154;
								setforegroundcolor_188057(stderr, ((NU8) 31), NIM_FALSE);
								LOC156 = 0;
								LOC156 = rawNewString(command_167240->Sup.len + 95);
appendString(LOC156, ((NimStringDesc*) &TMP494));
appendString(LOC156, command_167240);
appendString(LOC156, ((NimStringDesc*) &TMP495));
								write_17095(stderr, LOC156);
								write_17095(stderr, ((NimStringDesc*) &TMP432));
								resetattributes_187209(stderr);
							}
							goto LA152;
							LA154: ;
							{
								TY192421 LOC158;
								NimStringDesc* LOC159;
								memset((void*)LOC158, 0, sizeof(LOC158));
								LOC159 = 0;
								LOC159 = rawNewString(command_167240->Sup.len + 95);
appendString(LOC159, ((NimStringDesc*) &TMP494));
appendString(LOC159, command_167240);
appendString(LOC159, ((NimStringDesc*) &TMP495));
								LOC158[0] = LOC159;
								writeline_168405(stderr, LOC158, 1);
							}
							LA152: ;
						}
						LA150: ;
					}
					LA129: ;
				}
				LA122: ;
			}
			LA120: ;
			exit(((NI) 1));
		}
		goto LA59;
		LA112: ;
		{
			if (!(eh == ((NU8) 2))) goto LA161;
			raiserecoverableerror_191366(s_192441);
		}
		goto LA59;
		LA161: ;
		LA59: ;
	}
	LA57: ;
}

N_NIMCALL(void, rawmessage_193675)(NU16 msg, NimStringDesc** args, NI argsLen0) {
	NimStringDesc* title;
	NU8 color;
	NimStringDesc* kind;
	NimStringDesc* s_193777;
	NimStringDesc* LOC22;
{	title = 0;
	color = 0;
	kind = 0;
	switch (msg) {
	case ((NU16) 0) ... ((NU16) 236):
	{
		Tlineinfo190352 LOC2;
		LOC2 = unknownlineinfo_191408();
		writecontext_193266(LOC2);
		title = copyString(((NimStringDesc*) &TMP435));
		color = ((NU8) 31);
	}
	break;
	case ((NU16) 237) ... ((NU16) 267):
	{
		Tlineinfo190352 LOC12;
		{
			if (!!(((goptions_167130 &(1<<((((NU8) 11))&31)))!=0))) goto LA6;
			goto BeforeRet;
		}
		LA6: ;
		{
			if (!!(((gnotes_191395 &(IL64(1)<<(((((NU16) (msg))- 237))&IL64(63))))!=0))) goto LA10;
			goto BeforeRet;
		}
		LA10: ;
		LOC12 = unknownlineinfo_191408();
		writecontext_193266(LOC12);
		title = copyString(((NimStringDesc*) &TMP436));
		color = ((NU8) 33);
		kind = copyString(Warningstostr_190309[((NI)(((NI) (msg)) - ((NI) 237)))- 0]);
		gwarncounter_191398 += ((NI) 1);
	}
	break;
	case ((NU16) 268) ... ((NU16) 290):
	{
		{
			if (!!(((goptions_167130 &(1<<((((NU8) 12))&31)))!=0))) goto LA16;
			goto BeforeRet;
		}
		LA16: ;
		{
			if (!!(((gnotes_191395 &(IL64(1)<<(((((NU16) (msg))- 237))&IL64(63))))!=0))) goto LA20;
			goto BeforeRet;
		}
		LA20: ;
		title = copyString(((NimStringDesc*) &TMP468));
		color = ((NU8) 32);
		kind = copyString(Hintstostr_190314[((NI)(((NI) (msg)) - ((NI) 268)))- 0]);
		ghintcounter_191397 += ((NI) 1);
	}
	break;
	}
	LOC22 = 0;
	LOC22 = msgkindtostring_192406(msg);
	s_193777 = nsuFormatOpenArray(LOC22, args, argsLen0);
	{
		NIM_BOOL LOC25;
		LOC25 = 0;
		LOC25 = ignoremsgbecauseofidetools_193637(msg);
		if (!!(LOC25)) goto LA26;
		{
			if (!!((kind == NIM_NIL))) goto LA30;
			{
				NimStringDesc* s_193795;
				if (!!(writelnhook_191441.ClPrc == 0)) goto LA34;
				s_193795 = copyString(((NimStringDesc*) &TMP147));
				{
					NimStringDesc* arg_193797;
					NI i_194607;
					arg_193797 = 0;
					i_194607 = ((NI) 0);
					{
						while (1) {
							TY193293 LOC39;
							if (!(i_194607 < ((NI) 3))) goto LA38;
							memset((void*)LOC39, 0, sizeof(LOC39));
							LOC39[0] = copyString(title);
							LOC39[1] = copyString(s_193777);
							LOC39[2] = nsuFormatSingleElem(((NimStringDesc*) &TMP491), kind);
							arg_193797 = LOC39[(i_194607)- 0];
							s_193795 = resizeString(s_193795, arg_193797->Sup.len + 0);
appendString(s_193795, arg_193797);
							i_194607 += ((NI) 1);
						} LA38: ;
					}
				}
				writelnhook_191441.ClEnv? writelnhook_191441.ClPrc(s_193795, writelnhook_191441.ClEnv):((TMP492)(writelnhook_191441.ClPrc))(s_193795);
			}
			goto LA32;
			LA34: ;
			{
				if (!((gglobaloptions_167132 &(1<<((((NU8) 23))&31)))!=0)) goto LA41;
				{
					TY193293 LOC47;
					if (!((erroroutputs_191437 &(1<<((((NU8) 0))&7)))!=0)) goto LA45;
					memset((void*)LOC47, 0, sizeof(LOC47));
					LOC47[0] = copyString(title);
					LOC47[1] = copyString(s_193777);
					LOC47[2] = nsuFormatSingleElem(((NimStringDesc*) &TMP491), kind);
					writeline_168405(stdout, LOC47, 3);
					fflush(stdout);
				}
				LA45: ;
			}
			goto LA32;
			LA41: ;
			{
				{
					if (!((erroroutputs_191437 &(1<<((((NU8) 1))&7)))!=0)) goto LA51;
					{
						NimStringDesc* LOC57;
						if (!((gglobaloptions_167132 &(1<<((((NU8) 21))&31)))!=0)) goto LA55;
						setforegroundcolor_188057(stderr, color, NIM_FALSE);
						write_17095(stderr, title);
						resetattributes_187209(stderr);
						write_17095(stderr, s_193777);
						setforegroundcolor_188057(stderr, ((NU8) 36), NIM_FALSE);
						LOC57 = 0;
						LOC57 = nsuFormatSingleElem(((NimStringDesc*) &TMP491), kind);
						write_17095(stderr, LOC57);
						write_17095(stderr, ((NimStringDesc*) &TMP432));
						resetattributes_187209(stderr);
					}
					goto LA53;
					LA55: ;
					{
						TY193293 LOC59;
						memset((void*)LOC59, 0, sizeof(LOC59));
						LOC59[0] = copyString(title);
						LOC59[1] = copyString(s_193777);
						LOC59[2] = nsuFormatSingleElem(((NimStringDesc*) &TMP491), kind);
						writeline_168405(stderr, LOC59, 3);
					}
					LA53: ;
				}
				LA51: ;
			}
			LA32: ;
		}
		goto LA28;
		LA30: ;
		{
			{
				NimStringDesc* s_194217;
				if (!!(writelnhook_191441.ClPrc == 0)) goto LA63;
				s_194217 = copyString(((NimStringDesc*) &TMP147));
				{
					NimStringDesc* arg_194219;
					NI i_194611;
					arg_194219 = 0;
					i_194611 = ((NI) 0);
					{
						while (1) {
							TY193306 LOC68;
							if (!(i_194611 < ((NI) 2))) goto LA67;
							memset((void*)LOC68, 0, sizeof(LOC68));
							LOC68[0] = copyString(title);
							LOC68[1] = copyString(s_193777);
							arg_194219 = LOC68[(i_194611)- 0];
							s_194217 = resizeString(s_194217, arg_194219->Sup.len + 0);
appendString(s_194217, arg_194219);
							i_194611 += ((NI) 1);
						} LA67: ;
					}
				}
				writelnhook_191441.ClEnv? writelnhook_191441.ClPrc(s_194217, writelnhook_191441.ClEnv):((TMP493)(writelnhook_191441.ClPrc))(s_194217);
			}
			goto LA61;
			LA63: ;
			{
				if (!((gglobaloptions_167132 &(1<<((((NU8) 23))&31)))!=0)) goto LA70;
				{
					TY193306 LOC76;
					if (!((erroroutputs_191437 &(1<<((((NU8) 0))&7)))!=0)) goto LA74;
					memset((void*)LOC76, 0, sizeof(LOC76));
					LOC76[0] = copyString(title);
					LOC76[1] = copyString(s_193777);
					writeline_168405(stdout, LOC76, 2);
					fflush(stdout);
				}
				LA74: ;
			}
			goto LA61;
			LA70: ;
			{
				{
					if (!((erroroutputs_191437 &(1<<((((NU8) 1))&7)))!=0)) goto LA80;
					{
						if (!((gglobaloptions_167132 &(1<<((((NU8) 21))&31)))!=0)) goto LA84;
						setforegroundcolor_188057(stderr, color, NIM_FALSE);
						write_17095(stderr, title);
						resetattributes_187209(stderr);
						write_17095(stderr, s_193777);
						write_17095(stderr, ((NimStringDesc*) &TMP432));
						resetattributes_187209(stderr);
					}
					goto LA82;
					LA84: ;
					{
						TY193306 LOC87;
						memset((void*)LOC87, 0, sizeof(LOC87));
						LOC87[0] = copyString(title);
						LOC87[1] = copyString(s_193777);
						writeline_168405(stderr, LOC87, 2);
					}
					LA82: ;
				}
				LA80: ;
			}
			LA61: ;
		}
		LA28: ;
	}
	LA26: ;
	handleerror_192437(msg, ((NU8) 1), s_193777);
	}BeforeRet: ;
}

N_NIMCALL(void, rawmessage_194636)(NU16 msg, NimStringDesc* arg) {
	TY192421 LOC1;
	memset((void*)LOC1, 0, sizeof(LOC1));
	LOC1[0] = copyString(arg);
	rawmessage_193675(msg, LOC1, 1);
}

N_NIMCALL(void, internalerror_196191)(NimStringDesc* errmsg) {
	Tlineinfo190352 LOC5;
{	{
		if (!(gcmd_167134 == ((NU8) 14))) goto LA3;
		goto BeforeRet;
	}
	LA3: ;
	LOC5 = unknownlineinfo_191408();
	writecontext_193266(LOC5);
	rawmessage_194636(((NU16) 2), errmsg);
	}BeforeRet: ;
}

N_NIMCALL(void, HEX3Aanonymous_196653)(NU8 err, NimStringDesc* msg, NIM_BOOL usewarning) {
	switch (err) {
	case ((NU8) 1):
	{
		NimStringDesc* LOC2;
		LOC2 = 0;
		LOC2 = rawNewString(msg->Sup.len + 30);
appendString(LOC2, ((NimStringDesc*) &TMP500));
appendString(LOC2, msg);
		internalerror_196191(LOC2);
	}
	break;
	case ((NU8) 0):
	{
		NU16 LOC4;
		LOC4 = 0;
		{
			if (!usewarning) goto LA7;
			LOC4 = ((NU16) 237);
		}
		goto LA5;
		LA7: ;
		{
			LOC4 = ((NU16) 3);
		}
		LA5: ;
		rawmessage_194636(LOC4, msg);
	}
	break;
	}
}

static N_INLINE(NIM_BOOL, canbecycleroot_52867)(Cell49146* c) {
	NIM_BOOL result;
	result = 0;
	result = !((((*(*c).typ).flags &(1<<((((NU8) 1))&7)))!=0));
	return result;
}

static N_INLINE(void, rtladdcycleroot_53623)(Cell49146* c) {
	{
		if (!!((((NI) ((NI)((*c).refcount & ((NI) 3)))) == ((NI) 3)))) goto LA3;
		(*c).refcount = (NI)((NI)((*c).refcount & ((NI) -4)) | ((NI) 3));
		incl_49865((&gch_51259.cycleroots), c);
	}
	LA3: ;
}

static N_INLINE(void, incref_55222)(Cell49146* c) {
	(*c).refcount = (NI)((NU64)((*c).refcount) + (NU64)(((NI) 8)));
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = canbecycleroot_52867(c);
		if (!LOC3) goto LA4;
		rtladdcycleroot_53623(c);
	}
	LA4: ;
}

static N_INLINE(void, decref_54804)(Cell49146* c) {
	{
		(*c).refcount -= ((NI) 8);
		if (!((NU64)((*c).refcount) < (NU64)(((NI) 8)))) goto LA3;
		rtladdzct_54404(c);
	}
	goto LA1;
	LA3: ;
	{
		NIM_BOOL LOC6;
		LOC6 = 0;
		LOC6 = canbecycleroot_52867(c);
		if (!LOC6) goto LA7;
		rtladdcycleroot_53623(c);
	}
	goto LA1;
	LA7: ;
	LA1: ;
}

static N_INLINE(void, asgnRef)(void** dest, void* src) {
	{
		Cell49146* LOC5;
		if (!!((src == NIM_NIL))) goto LA3;
		LOC5 = 0;
		LOC5 = usrtocell_52846(src);
		incref_55222(LOC5);
	}
	LA3: ;
	{
		Cell49146* LOC10;
		if (!!(((*dest) == NIM_NIL))) goto LA8;
		LOC10 = 0;
		LOC10 = usrtocell_52846((*dest));
		decref_54804(LOC10);
	}
	LA8: ;
	(*dest) = src;
}

static N_INLINE(NIM_BOOL, contains_196021)(Slice196011 s, NU16 value) {
	NIM_BOOL result;
	NIM_BOOL LOC1;
	result = 0;
	LOC1 = 0;
	LOC1 = (s.a <= value);
	if (!(LOC1)) goto LA2;
	LOC1 = (value <= s.b);
	LA2: ;
	result = LOC1;
	return result;
}

static N_INLINE(Slice196011, HEX2EHEX2E_196002)(NU16 a, NU16 b) {
	Slice196011 result;
	memset((void*)(&result), 0, sizeof(result));
	result.a = a;
	result.b = b;
	return result;
}

N_NIMCALL(void, msgwriteln_191915)(NimStringDesc* s, NU8 flags) {
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = !(writelnhook_191441.ClPrc == 0);
		if (!(LOC3)) goto LA4;
		LOC3 = !(((flags &(1<<((((NU8) 1))&7)))!=0));
		LA4: ;
		if (!LOC3) goto LA5;
		writelnhook_191441.ClEnv? writelnhook_191441.ClPrc(s, writelnhook_191441.ClEnv):((TMP1047)(writelnhook_191441.ClPrc))(s);
	}
	goto LA1;
	LA5: ;
	{
		NIM_BOOL LOC8;
		LOC8 = 0;
		LOC8 = ((gglobaloptions_167132 &(1<<((((NU8) 23))&31)))!=0);
		if (LOC8) goto LA9;
		LOC8 = ((flags &(1<<((((NU8) 0))&7)))!=0);
		LA9: ;
		if (!LOC8) goto LA10;
		{
			TY192421 LOC16;
			if (!((erroroutputs_191437 &(1<<((((NU8) 0))&7)))!=0)) goto LA14;
			memset((void*)LOC16, 0, sizeof(LOC16));
			LOC16[0] = copyString(s);
			writeline_168405(stdout, LOC16, 1);
			fflush(stdout);
		}
		LA14: ;
	}
	goto LA1;
	LA10: ;
	{
		{
			TY192421 LOC22;
			if (!((erroroutputs_191437 &(1<<((((NU8) 1))&7)))!=0)) goto LA20;
			memset((void*)LOC22, 0, sizeof(LOC22));
			LOC22[0] = copyString(s);
			writeline_168405(stderr, LOC22, 1);
		}
		LA20: ;
	}
	LA1: ;
}

static N_INLINE(void, pushSafePoint)(TSafePoint* s) {
	(*s).hasRaiseAction = NIM_FALSE;
	(*s).prev = exchandler_21043;
	exchandler_21043 = s;
}

N_NIMCALL(NimStringDesc*, tofullpath_191662)(NI32 fileidx) {
	NimStringDesc* result;
	result = 0;
	{
		if (!(fileidx < ((NI32) 0))) goto LA3;
		result = copyString(((NimStringDesc*) &TMP155));
	}
	goto LA1;
	LA3: ;
	{
		result = copyString(fileinfos_190632->data[fileidx].fullpath);
	}
	LA1: ;
	return result;
}

static N_INLINE(void, asgnRefNoCycle)(void** dest, void* src) {
	{
		Cell49146* c;
		if (!!((src == NIM_NIL))) goto LA3;
		c = usrtocell_52846(src);
		(*c).refcount += ((NI) 8);
	}
	LA3: ;
	{
		Cell49146* c;
		if (!!(((*dest) == NIM_NIL))) goto LA7;
		c = usrtocell_52846((*dest));
		{
			(*c).refcount -= ((NI) 8);
			if (!((NU64)((*c).refcount) < (NU64)(((NI) 8)))) goto LA11;
			rtladdzct_54404(c);
		}
		LA11: ;
	}
	LA7: ;
	(*dest) = src;
}

N_NIMCALL(void, addsourceline_196227)(NI32 fileidx, NimStringDesc* line) {
	Ropeobj176009* LOC1;
	LOC1 = 0;
	LOC1 = rope_176322(line);
	fileinfos_190632->data[fileidx].lines = (TY190365*) incrSeqV2(&(fileinfos_190632->data[fileidx].lines)->Sup, sizeof(Ropeobj176009*));
	asgnRefNoCycle((void**) (&fileinfos_190632->data[fileidx].lines->data[fileinfos_190632->data[fileidx].lines->Sup.len]), LOC1);
	++fileinfos_190632->data[fileidx].lines->Sup.len;
}

static N_INLINE(void, popSafePoint)(void) {
	exchandler_21043 = (*exchandler_21043).prev;
}

static N_INLINE(Exception*, getCurrentException)(void) {
	Exception* result;
	result = 0;
	result = currexception_21045;
	return result;
}

static N_INLINE(void, popCurrentException)(void) {
	asgnRef((void**) (&currexception_21045), NIM_NIL);
}

N_NIMCALL(Ropeobj176009*, sourceline_191389)(Tlineinfo190352 i) {
	Ropeobj176009* result;
{	result = 0;
	{
		if (!(i.fileindex < ((NI32) 0))) goto LA3;
		result = NIM_NIL;
		goto BeforeRet;
	}
	LA3: ;
	{
		NIM_BOOL LOC7;
		TSafePoint TMP1049;
		LOC7 = 0;
		LOC7 = !(((gglobaloptions_167132 &(1<<((((NU8) 28))&31)))!=0));
		if (!(LOC7)) goto LA8;
		LOC7 = ((fileinfos_190632->data[i.fileindex].lines ? fileinfos_190632->data[i.fileindex].lines->Sup.len : 0) == ((NI) 0));
		LA8: ;
		if (!LOC7) goto LA9;
		pushSafePoint(&TMP1049);
		TMP1049.status = _setjmp(TMP1049.context);
		if (TMP1049.status == 0) {
			{
				NimStringDesc* line_196269;
				NimStringDesc* HEX3Atmp_196614;
				FILE* f_196617;
				NimStringDesc* res_196619;
				line_196269 = 0;
				HEX3Atmp_196614 = 0;
				HEX3Atmp_196614 = tofullpath_191662(i.fileindex);
				f_196617 = open_17017(HEX3Atmp_196614, ((NU8) 0), ((NI) 8000));
				res_196619 = rawNewString(((NI) 80));
				{
					while (1) {
						NIM_BOOL LOC15;
						LOC15 = 0;
						LOC15 = readline_17119(f_196617, (&res_196619));
						if (!LOC15) goto LA14;
						line_196269 = res_196619;
						addsourceline_196227(i.fileindex, line_196269);
					} LA14: ;
				}
				fclose(f_196617);
			}
			popSafePoint();
		}
		else {
			popSafePoint();
			if (isObj(getCurrentException()->Sup.m_type, (&NTI4031))) {
				TMP1049.status = 0;
				popCurrentException();
			}
		}
		if (TMP1049.status != 0) reraiseException();
	}
	LA9: ;
	{
		NimStringDesc* LOC22;
		if (!!((((NI) (i.fileindex)) < (fileinfos_190632 ? fileinfos_190632->Sup.len : 0)))) goto LA20;
		LOC22 = 0;
		LOC22 = HEX24_196279(TMP1065);
		internalerror_196191(LOC22);
	}
	LA20: ;
	{
		if (!((fileinfos_190632->data[i.fileindex].lines ? fileinfos_190632->data[i.fileindex].lines->Sup.len : 0) < ((NI) (i.line)))) goto LA25;
		result = NIM_NIL;
		goto BeforeRet;
	}
	LA25: ;
	result = fileinfos_190632->data[i.fileindex].lines->data[(NI16)(i.line - ((NI16) 1))];
	}BeforeRet: ;
	return result;
}

N_NIMCALL(void, writesurroundingsrc_194681)(Tlineinfo190352 info) {
	NimStringDesc* LOC1;
	Ropeobj176009* LOC2;
	NimStringDesc* LOC3;
	NimStringDesc* LOC4;
	NimStringDesc* LOC5;
	LOC1 = 0;
	LOC2 = 0;
	LOC2 = sourceline_191389(info);
	LOC3 = 0;
	LOC3 = HEX24_177132(LOC2);
	LOC1 = rawNewString(LOC3->Sup.len + 2);
appendString(LOC1, ((NimStringDesc*) &TMP1048));
appendString(LOC1, LOC3);
	msgwriteln_191915(LOC1, 0);
	LOC4 = 0;
	LOC5 = 0;
	LOC5 = nsuRepeatChar(32, ((NI) (info.col)));
	LOC4 = rawNewString(LOC5->Sup.len + 3);
appendString(LOC4, ((NimStringDesc*) &TMP1048));
appendString(LOC4, LOC5);
appendChar(LOC4, 94);
	msgwriteln_191915(LOC4, 0);
}

N_NIMCALL(void, limessage_194706)(Tlineinfo190352 info, NU16 msg, NimStringDesc* arg, NU8 eh) {
	NimStringDesc* title;
	NU8 color;
	NimStringDesc* kind;
	NIM_BOOL ignoremsg;
	NimStringDesc* x;
	TY193293 LOC12;
	NimStringDesc* s_194813;
	title = 0;
	color = 0;
	kind = 0;
	ignoremsg = NIM_FALSE;
	switch (msg) {
	case ((NU16) 0) ... ((NU16) 236):
	{
		writecontext_193266(info);
		title = copyString(((NimStringDesc*) &TMP435));
		color = ((NU8) 31);
		lasterror_191435 = info;
	}
	break;
	case ((NU16) 237) ... ((NU16) 267):
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = !(((goptions_167130 &(1<<((((NU8) 11))&31)))!=0));
		if (LOC3) goto LA4;
		LOC3 = !(((gnotes_191395 &(IL64(1)<<(((((NU16) (msg))- 237))&IL64(63))))!=0));
		LA4: ;
		ignoremsg = LOC3;
		{
			if (!!(ignoremsg)) goto LA7;
			writecontext_193266(info);
		}
		LA7: ;
		title = copyString(((NimStringDesc*) &TMP436));
		color = ((NU8) 33);
		kind = copyString(Warningstostr_190309[((NI)(((NI) (msg)) - ((NI) 237)))- 0]);
		gwarncounter_191398 += ((NI) 1);
	}
	break;
	case ((NU16) 268) ... ((NU16) 290):
	{
		NIM_BOOL LOC10;
		LOC10 = 0;
		LOC10 = !(((goptions_167130 &(1<<((((NU8) 12))&31)))!=0));
		if (LOC10) goto LA11;
		LOC10 = !(((gnotes_191395 &(IL64(1)<<(((((NU16) (msg))- 237))&IL64(63))))!=0));
		LA11: ;
		ignoremsg = LOC10;
		title = copyString(((NimStringDesc*) &TMP468));
		color = ((NU8) 32);
		kind = copyString(Hintstostr_190314[((NI)(((NI) (msg)) - ((NI) 268)))- 0]);
		ghintcounter_191397 += ((NI) 1);
	}
	break;
	}
	memset((void*)LOC12, 0, sizeof(LOC12));
	LOC12[0] = tomsgfilename_191829(info);
	LOC12[1] = coordtostr_192396(((NI) (info.line)));
	LOC12[2] = coordtostr_192396(((NI) ((NI16)(info.col + ((NI16) 1)))));
	x = nsuFormatOpenArray(((NimStringDesc*) &TMP154), LOC12, 3);
	s_194813 = getmessagestr_192416(msg, arg);
	{
		NIM_BOOL LOC15;
		NIM_BOOL LOC17;
		LOC15 = 0;
		LOC15 = !(ignoremsg);
		if (!(LOC15)) goto LA16;
		LOC17 = 0;
		LOC17 = ignoremsgbecauseofidetools_193637(msg);
		LOC15 = !(LOC17);
		LA16: ;
		if (!LOC15) goto LA18;
		{
			if (!!((kind == NIM_NIL))) goto LA22;
			{
				NimStringDesc* s_194832;
				if (!!(writelnhook_191441.ClPrc == 0)) goto LA26;
				s_194832 = copyString(((NimStringDesc*) &TMP147));
				{
					NimStringDesc* arg_194834;
					NI i_196067;
					arg_194834 = 0;
					i_196067 = ((NI) 0);
					{
						while (1) {
							TY194829 LOC31;
							if (!(i_196067 < ((NI) 4))) goto LA30;
							memset((void*)LOC31, 0, sizeof(LOC31));
							LOC31[0] = copyString(x);
							LOC31[1] = copyString(title);
							LOC31[2] = copyString(s_194813);
							LOC31[3] = nsuFormatSingleElem(((NimStringDesc*) &TMP491), kind);
							arg_194834 = LOC31[(i_196067)- 0];
							s_194832 = resizeString(s_194832, arg_194834->Sup.len + 0);
appendString(s_194832, arg_194834);
							i_196067 += ((NI) 1);
						} LA30: ;
					}
				}
				writelnhook_191441.ClEnv? writelnhook_191441.ClPrc(s_194832, writelnhook_191441.ClEnv):((TMP1045)(writelnhook_191441.ClPrc))(s_194832);
			}
			goto LA24;
			LA26: ;
			{
				if (!((gglobaloptions_167132 &(1<<((((NU8) 23))&31)))!=0)) goto LA33;
				{
					TY194829 LOC39;
					if (!((erroroutputs_191437 &(1<<((((NU8) 0))&7)))!=0)) goto LA37;
					memset((void*)LOC39, 0, sizeof(LOC39));
					LOC39[0] = copyString(x);
					LOC39[1] = copyString(title);
					LOC39[2] = copyString(s_194813);
					LOC39[3] = nsuFormatSingleElem(((NimStringDesc*) &TMP491), kind);
					writeline_168405(stdout, LOC39, 4);
					fflush(stdout);
				}
				LA37: ;
			}
			goto LA24;
			LA33: ;
			{
				{
					if (!((erroroutputs_191437 &(1<<((((NU8) 1))&7)))!=0)) goto LA43;
					{
						NimStringDesc* LOC49;
						if (!((gglobaloptions_167132 &(1<<((((NU8) 21))&31)))!=0)) goto LA47;
						setstyle_187604(stderr, 1);
						write_17095(stderr, x);
						resetattributes_187209(stderr);
						setforegroundcolor_188057(stderr, color, NIM_FALSE);
						write_17095(stderr, title);
						resetattributes_187209(stderr);
						write_17095(stderr, s_194813);
						setforegroundcolor_188057(stderr, ((NU8) 36), NIM_FALSE);
						LOC49 = 0;
						LOC49 = nsuFormatSingleElem(((NimStringDesc*) &TMP491), kind);
						write_17095(stderr, LOC49);
						write_17095(stderr, ((NimStringDesc*) &TMP432));
						resetattributes_187209(stderr);
					}
					goto LA45;
					LA47: ;
					{
						TY194829 LOC51;
						memset((void*)LOC51, 0, sizeof(LOC51));
						LOC51[0] = copyString(x);
						LOC51[1] = copyString(title);
						LOC51[2] = copyString(s_194813);
						LOC51[3] = nsuFormatSingleElem(((NimStringDesc*) &TMP491), kind);
						writeline_168405(stderr, LOC51, 4);
					}
					LA45: ;
				}
				LA43: ;
			}
			LA24: ;
		}
		goto LA20;
		LA22: ;
		{
			{
				NimStringDesc* s_195418;
				if (!!(writelnhook_191441.ClPrc == 0)) goto LA55;
				s_195418 = copyString(((NimStringDesc*) &TMP147));
				{
					NimStringDesc* arg_195420;
					NI i_196071;
					arg_195420 = 0;
					i_196071 = ((NI) 0);
					{
						while (1) {
							TY193293 LOC60;
							if (!(i_196071 < ((NI) 3))) goto LA59;
							memset((void*)LOC60, 0, sizeof(LOC60));
							LOC60[0] = copyString(x);
							LOC60[1] = copyString(title);
							LOC60[2] = copyString(s_194813);
							arg_195420 = LOC60[(i_196071)- 0];
							s_195418 = resizeString(s_195418, arg_195420->Sup.len + 0);
appendString(s_195418, arg_195420);
							i_196071 += ((NI) 1);
						} LA59: ;
					}
				}
				writelnhook_191441.ClEnv? writelnhook_191441.ClPrc(s_195418, writelnhook_191441.ClEnv):((TMP1046)(writelnhook_191441.ClPrc))(s_195418);
			}
			goto LA53;
			LA55: ;
			{
				if (!((gglobaloptions_167132 &(1<<((((NU8) 23))&31)))!=0)) goto LA62;
				{
					TY193293 LOC68;
					if (!((erroroutputs_191437 &(1<<((((NU8) 0))&7)))!=0)) goto LA66;
					memset((void*)LOC68, 0, sizeof(LOC68));
					LOC68[0] = copyString(x);
					LOC68[1] = copyString(title);
					LOC68[2] = copyString(s_194813);
					writeline_168405(stdout, LOC68, 3);
					fflush(stdout);
				}
				LA66: ;
			}
			goto LA53;
			LA62: ;
			{
				{
					if (!((erroroutputs_191437 &(1<<((((NU8) 1))&7)))!=0)) goto LA72;
					{
						if (!((gglobaloptions_167132 &(1<<((((NU8) 21))&31)))!=0)) goto LA76;
						setstyle_187604(stderr, 1);
						write_17095(stderr, x);
						resetattributes_187209(stderr);
						setforegroundcolor_188057(stderr, color, NIM_FALSE);
						write_17095(stderr, title);
						resetattributes_187209(stderr);
						write_17095(stderr, s_194813);
						write_17095(stderr, ((NimStringDesc*) &TMP432));
						resetattributes_187209(stderr);
					}
					goto LA74;
					LA76: ;
					{
						TY193293 LOC79;
						memset((void*)LOC79, 0, sizeof(LOC79));
						LOC79[0] = copyString(x);
						LOC79[1] = copyString(title);
						LOC79[2] = copyString(s_194813);
						writeline_168405(stderr, LOC79, 3);
					}
					LA74: ;
				}
				LA72: ;
			}
			LA53: ;
		}
		LA20: ;
		{
			NIM_BOOL LOC82;
			Slice196011 LOC83;
			LOC82 = 0;
			LOC83 = HEX2EHEX2E_196002(((NU16) 0), ((NU16) 236));
			LOC82 = contains_196021(LOC83, msg);
			if (!(LOC82)) goto LA84;
			LOC82 = ((gnotes_191395 &(IL64(1)<<(((((NU16) 287)- 237))&IL64(63))))!=0);
			LA84: ;
			if (!LOC82) goto LA85;
			writesurroundingsrc_194681(info);
		}
		LA85: ;
	}
	LA18: ;
	handleerror_192437(msg, eh, s_194813);
}

N_NIMCALL(void, internalerror_196172)(Tlineinfo190352 info, NimStringDesc* errmsg) {
{	{
		if (!(gcmd_167134 == ((NU8) 14))) goto LA3;
		goto BeforeRet;
	}
	LA3: ;
	writecontext_193266(info);
	limessage_194706(info, ((NU16) 2), errmsg, ((NU8) 1));
	}BeforeRet: ;
}

N_NIMCALL(NimStringDesc*, tofullpathconsiderdirty_191807)(NI32 fileidx) {
	NimStringDesc* result;
	result = 0;
	{
		if (!(fileidx < ((NI32) 0))) goto LA3;
		result = copyString(((NimStringDesc*) &TMP155));
	}
	goto LA1;
	LA3: ;
	{
		if (!!(fileinfos_190632->data[fileidx].dirtyfile == 0)) goto LA6;
		result = copyString(fileinfos_190632->data[fileidx].dirtyfile);
	}
	goto LA1;
	LA6: ;
	{
		result = copyString(fileinfos_190632->data[fileidx].fullpath);
	}
	LA1: ;
	return result;
}

N_NIMCALL(void, message_196161)(Tlineinfo190352 info, NU16 msg, NimStringDesc* arg) {
	limessage_194706(info, msg, arg, ((NU8) 0));
}

static N_INLINE(void, shallow_91824)(NimStringDesc** s_91827) {
	TGenericSeq* s;
	s = ((TGenericSeq*) ((*s_91827)));
	(*s).reserved = (NI)((*s).reserved | ((NI) (IL64(-9223372036854775807) - IL64(1))));
}

N_NIMCALL(NI32, fileinfoidx_190732)(NimStringDesc* filename, NIM_BOOL* isknownfile) {
	NI32 result;
	NimStringDesc* volatile canon;
	NIM_BOOL pseudopath;
	TSafePoint TMP1188;
	result = 0;
	canon = 0;
	pseudopath = NIM_FALSE;
	pushSafePoint(&TMP1188);
	TMP1188.status = _setjmp(TMP1188.context);
	if (TMP1188.status == 0) {
		canon = canonicalizepath_167409(filename);
		shallow_91824((&canon));
		popSafePoint();
	}
	else {
		popSafePoint();
		{
			TMP1188.status = 0;
			canon = copyString(filename);
			pseudopath = NIM_TRUE;
			popCurrentException();
		}
	}
	if (TMP1188.status != 0) reraiseException();
	{
		NIM_BOOL LOC6;
		NI32* LOC9;
		LOC6 = 0;
		LOC6 = haskey_190742(filenametoindextbl_190614, canon);
		if (!LOC6) goto LA7;
		LOC9 = 0;
		LOC9 = HEX5BHEX5D_190786((&filenametoindextbl_190614), canon);
		result = (*LOC9);
	}
	goto LA4;
	LA7: ;
	{
		NimStringDesc* LOC11;
		Tfileinfo190350 LOC17;
		(*isknownfile) = NIM_FALSE;
		result = ((NI32) ((fileinfos_190632 ? fileinfos_190632->Sup.len : 0)));
		LOC11 = 0;
		{
			if (!pseudopath) goto LA14;
			LOC11 = copyString(filename);
		}
		goto LA12;
		LA14: ;
		{
			LOC11 = shortendir_167607(canon);
		}
		LA12: ;
		memset((void*)(&LOC17), 0, sizeof(LOC17));
		newfileinfo_190694(canon, LOC11, (&LOC17));
		fileinfos_190632 = (TY190615*) incrSeqV2(&(fileinfos_190632)->Sup, sizeof(Tfileinfo190350));
		genericAssign((void*)(&fileinfos_190632->data[fileinfos_190632->Sup.len]), (void*)(&LOC17), (&NTI190350));
		++fileinfos_190632->Sup.len;
		HEX5BHEX5DHEX3D_191038((&filenametoindextbl_190614), canon, result);
	}
	LA4: ;
	return result;
}

N_NIMCALL(NI32, fileinfoidx_191253)(NimStringDesc* filename) {
	NI32 result;
	NIM_BOOL dummy;
	result = 0;
	dummy = 0;
	result = fileinfoidx_190732(filename, (&dummy));
	return result;
}

N_NIMCALL(void, localerror_196128)(Tlineinfo190352 info, NU16 msg, NimStringDesc* arg) {
	limessage_194706(info, msg, arg, ((NU8) 0));
}

N_NIMCALL(NimStringDesc*, tofilename_191652)(NI32 fileidx) {
	NimStringDesc* result;
	result = 0;
	{
		if (!(fileidx < ((NI32) 0))) goto LA3;
		result = copyString(((NimStringDesc*) &TMP155));
	}
	goto LA1;
	LA3: ;
	{
		result = copyString(fileinfos_190632->data[fileidx].projpath);
	}
	LA1: ;
	return result;
}

N_NIMCALL(void, listwarnings_196769)(void) {
	msgwriteln_191915(((NimStringDesc*) &TMP1897), 0);
	{
		NU16 warn_196823;
		NI res_196857;
		warn_196823 = 0;
		res_196857 = ((NI) 237);
		{
			while (1) {
				TY193306 LOC4;
				NimStringDesc* LOC10;
				if (!(res_196857 <= ((NI) 267))) goto LA3;
				warn_196823 = ((NU16) (res_196857));
				memset((void*)LOC4, 0, sizeof(LOC4));
				{
					if (!((gnotes_191395 &(IL64(1)<<(((((NU16) (warn_196823))- 237))&IL64(63))))!=0)) goto LA7;
					LOC4[0] = copyString(((NimStringDesc*) &TMP1899));
				}
				goto LA5;
				LA7: ;
				{
					LOC4[0] = copyString(((NimStringDesc*) &TMP1900));
				}
				LA5: ;
				LOC4[1] = copyString(Warningstostr_190309[((NI)(((NI) (warn_196823)) - ((NI) 237)))- 0]);
				LOC10 = 0;
				LOC10 = nsuFormatOpenArray(((NimStringDesc*) &TMP1898), LOC4, 2);
				msgwriteln_191915(LOC10, 0);
				res_196857 += ((NI) 1);
			} LA3: ;
		}
	}
}

N_NIMCALL(void, localerror_196139)(Tlineinfo190352 info, NimStringDesc* arg) {
	limessage_194706(info, ((NU16) 4), arg, ((NU8) 0));
}

N_NIMCALL(void, listhints_196875)(void) {
	msgwriteln_191915(((NimStringDesc*) &TMP1959), 0);
	{
		NU16 hint_196887;
		NI res_196921;
		hint_196887 = 0;
		res_196921 = ((NI) 268);
		{
			while (1) {
				TY193306 LOC4;
				NimStringDesc* LOC10;
				if (!(res_196921 <= ((NI) 290))) goto LA3;
				hint_196887 = ((NU16) (res_196921));
				memset((void*)LOC4, 0, sizeof(LOC4));
				{
					if (!((gnotes_191395 &(IL64(1)<<(((((NU16) (hint_196887))- 237))&IL64(63))))!=0)) goto LA7;
					LOC4[0] = copyString(((NimStringDesc*) &TMP1899));
				}
				goto LA5;
				LA7: ;
				{
					LOC4[0] = copyString(((NimStringDesc*) &TMP1900));
				}
				LA5: ;
				LOC4[1] = copyString(Hintstostr_190314[((NI)(((NI) (hint_196887)) - ((NI) 268)))- 0]);
				LOC10 = 0;
				LOC10 = nsuFormatOpenArray(((NimStringDesc*) &TMP1898), LOC4, 2);
				msgwriteln_191915(LOC10, 0);
				res_196921 += ((NI) 1);
			} LA3: ;
		}
	}
}

N_NIMCALL(void, msgquit_191488)(NI8 x) {
	exit(((NI) (x)));
}

N_NIMCALL(void, setdirtyfile_191672)(NI32 fileidx, NimStringDesc* filename) {
	NimStringDesc* LOC1;
	LOC1 = 0;
	LOC1 = fileinfos_190632->data[fileidx].dirtyfile; fileinfos_190632->data[fileidx].dirtyfile = copyStringRC1(filename);
	if (LOC1) nimGCunrefNoCycle(LOC1);
}

N_NIMCALL(void, suggestwriteln_191450)(NimStringDesc* s) {
	{
		if (!((erroroutputs_191437 &(1<<((((NU8) 0))&7)))!=0)) goto LA3;
		{
			TY192421 LOC9;
			if (!writelnhook_191441.ClPrc == 0) goto LA7;
			memset((void*)LOC9, 0, sizeof(LOC9));
			LOC9[0] = copyString(s);
			writeline_168405(stdout, LOC9, 1);
			fflush(stdout);
		}
		goto LA5;
		LA7: ;
		{
			writelnhook_191441.ClEnv? writelnhook_191441.ClPrc(s, writelnhook_191441.ClEnv):((TMP2061)(writelnhook_191441.ClPrc))(s);
		}
		LA5: ;
	}
	LA3: ;
}

N_NIMCALL(void, globalerror_196107)(Tlineinfo190352 info, NU16 msg, NimStringDesc* arg) {
	limessage_194706(info, msg, arg, ((NU8) 2));
}

N_NIMCALL(void, pushinfocontext_191578)(Tlineinfo190352 info) {
	msgcontext_191434 = (TY191417*) incrSeqV2(&(msgcontext_191434)->Sup, sizeof(Tlineinfo190352));
	msgcontext_191434->data[msgcontext_191434->Sup.len] = info;
	++msgcontext_191434->Sup.len;
}

N_NIMCALL(void, popinfocontext_191597)(void) {
	msgcontext_191434 = (TY191417*) setLengthSeq(&(msgcontext_191434)->Sup, sizeof(Tlineinfo190352), ((NI) ((NI)((msgcontext_191434 ? msgcontext_191434->Sup.len : 0) - ((NI) 1)))));
}
N_NIMCALL(void, TMP2771)(void* p, NI op) {
	Esuggestdone190360* a;
	a = (Esuggestdone190360*)p;
	nimGCvisit((void*)(*a).Sup.parent, op);
	nimGCvisit((void*)(*a).Sup.message, op);
	nimGCvisit((void*)(*a).Sup.trace, op);
}

N_NIMCALL(void, suggestquit_191506)(void) {
	Esuggestdone190360* e_191511;
	NimStringDesc* LOC1;
	e_191511 = 0;
	e_191511 = (Esuggestdone190360*) newObj((&NTI191512), sizeof(Esuggestdone190360));
	(*e_191511).Sup.Sup.m_type = (&NTI190360);
	LOC1 = 0;
	LOC1 = (*e_191511).Sup.message; (*e_191511).Sup.message = copyStringRC1(((NimStringDesc*) &TMP2772));
	if (LOC1) nimGCunrefNoCycle(LOC1);
	raiseException((Exception*)e_191511, "ESuggestDone");
}

N_NIMCALL(void, globalerror_196118)(Tlineinfo190352 info, NimStringDesc* arg) {
	limessage_194706(info, ((NU16) 4), arg, ((NU8) 2));
}

N_NIMCALL(NimStringDesc*, formatmsg_194691)(Tlineinfo190352 info, NU16 msg, NimStringDesc* arg) {
	NimStringDesc* result;
	NimStringDesc* title;
	NimStringDesc* LOC4;
	TY193293 LOC5;
	NimStringDesc* LOC6;
	NimStringDesc* LOC7;
	result = 0;
	switch (msg) {
	case ((NU16) 237) ... ((NU16) 267):
	{
		title = copyString(((NimStringDesc*) &TMP436));
	}
	break;
	case ((NU16) 268) ... ((NU16) 290):
	{
		title = copyString(((NimStringDesc*) &TMP468));
	}
	break;
	default:
	{
		title = copyString(((NimStringDesc*) &TMP435));
	}
	break;
	}
	LOC4 = 0;
	memset((void*)LOC5, 0, sizeof(LOC5));
	LOC5[0] = tomsgfilename_191829(info);
	LOC5[1] = coordtostr_192396(((NI) (info.line)));
	LOC5[2] = coordtostr_192396(((NI) ((NI16)(info.col + ((NI16) 1)))));
	LOC6 = 0;
	LOC6 = nsuFormatOpenArray(((NimStringDesc*) &TMP154), LOC5, 3);
	LOC7 = 0;
	LOC7 = getmessagestr_192416(msg, arg);
	LOC4 = rawNewString(LOC6->Sup.len + title->Sup.len + LOC7->Sup.len + 0);
appendString(LOC4, LOC6);
appendString(LOC4, title);
appendString(LOC4, LOC7);
	result = LOC4;
	return result;
}

N_NIMCALL(void, fatal_196096)(Tlineinfo190352 info, NU16 msg, NimStringDesc* arg) {
	limessage_194706(info, msg, arg, ((NU8) 1));
}

N_NIMCALL(Tlineinfo190352, getinfocontext_191623)(NI index) {
	Tlineinfo190352 result;
	NI L;
	NI i;
	memset((void*)(&result), 0, sizeof(result));
	L = (msgcontext_191434 ? msgcontext_191434->Sup.len : 0);
	{
		if (!(index < ((NI) 0))) goto LA3;
		i = (NI)(L + index);
	}
	goto LA1;
	LA3: ;
	{
		i = index;
	}
	LA1: ;
	{
		if (!((NU64)(L) <= (NU64)(i))) goto LA8;
		result = unknownlineinfo_191408();
	}
	goto LA6;
	LA8: ;
	{
		result = msgcontext_191434->data[i];
	}
	LA6: ;
	return result;
}

static N_INLINE(NimStringDesc*, tofilelinecol_191869)(Tlineinfo190352 info) {
	NimStringDesc* result;
	NimStringDesc* LOC1;
	NimStringDesc* LOC2;
	NimStringDesc* LOC3;
	NimStringDesc* LOC4;
	result = 0;
	LOC1 = 0;
	LOC2 = 0;
	LOC2 = tofilename_191652(info.fileindex);
	LOC3 = 0;
	LOC3 = nimIntToStr(((NI) (info.line)));
	LOC4 = 0;
	LOC4 = nimIntToStr(((NI) (info.col)));
	LOC1 = rawNewString(LOC2->Sup.len + LOC3->Sup.len + LOC4->Sup.len + 3);
appendString(LOC1, LOC2);
appendString(LOC1, ((NimStringDesc*) &TMP3232));
appendString(LOC1, LOC3);
appendString(LOC1, ((NimStringDesc*) &TMP3233));
appendString(LOC1, LOC4);
appendString(LOC1, ((NimStringDesc*) &TMP3234));
	result = LOC1;
	return result;
}

N_NIMCALL(NimStringDesc*, HEX24_191879)(Tlineinfo190352 info) {
	NimStringDesc* result;
	result = 0;
	result = tofilelinecol_191869(info);
	return result;
}

N_NIMCALL(NI, getinfocontextlen_191542)(void) {
	NI result;
{	result = 0;
	result = (msgcontext_191434 ? msgcontext_191434->Sup.len : 0);
	goto BeforeRet;
	}BeforeRet: ;
	return result;
}

N_NIMCALL(void, setinfocontextlen_191559)(NI L) {
	msgcontext_191434 = (TY191417*) setLengthSeq(&(msgcontext_191434)->Sup, sizeof(Tlineinfo190352), ((NI) (L)));
}

N_NIMCALL(Ropeobj176009*, quotedfilename_196636)(Tlineinfo190352 i) {
	Ropeobj176009* result;
	result = 0;
	{
		NimStringDesc* LOC5;
		if (!!((((NI32) 0) <= i.fileindex))) goto LA3;
		LOC5 = 0;
		LOC5 = HEX24_196279(TMP3998);
		internalerror_196191(LOC5);
	}
	LA3: ;
	result = fileinfos_190632->data[i.fileindex].quotedname;
	return result;
}

N_NIMCALL(void, resetattributes_194648)(void) {
	{
		if (!((10485760 & gglobaloptions_167132) == 2097152)) goto LA3;
		resetattributes_187209(stderr);
	}
	LA3: ;
}
NIM_EXTERNC N_NOINLINE(void, compiler_msgsInit000)(void) {
	Tfileinfo190350 LOC1;
	Tfileinfo190350 LOC2;
	NI LOC3;
	NI LOC4;
	NI LOC5;
	TY176023 LOC6;
	chckNil((void*)(&filenametoindextbl_190614));
	genericReset((void*)(&filenametoindextbl_190614), (&NTI190452));
	inittable_190444(((NI) 64), (&filenametoindextbl_190614));
	if (fileinfos_190632) nimGCunrefNoCycle(fileinfos_190632);
	fileinfos_190632 = (TY190615*) newSeqRC1((&NTI190615), 0);
	memset((void*)(&LOC1), 0, sizeof(LOC1));
	newfileinfo_190694(((NimStringDesc*) &TMP147), ((NimStringDesc*) &TMP149), (&LOC1));
	fileinfos_190632 = (TY190615*) incrSeqV2(&(fileinfos_190632)->Sup, sizeof(Tfileinfo190350));
	genericAssign((void*)(&fileinfos_190632->data[fileinfos_190632->Sup.len]), (void*)(&LOC1), (&NTI190350));
	++fileinfos_190632->Sup.len;
	gcmdlineinfo_191321 = newlineinfo_191266(((NI32) 0), ((NI) 1), ((NI) 1));
	memset((void*)(&LOC2), 0, sizeof(LOC2));
	newfileinfo_190694(((NimStringDesc*) &TMP147), ((NimStringDesc*) &TMP150), (&LOC2));
	fileinfos_190632 = (TY190615*) incrSeqV2(&(fileinfos_190632)->Sup, sizeof(Tfileinfo190350));
	genericAssign((void*)(&fileinfos_190632->data[fileinfos_190632->Sup.len]), (void*)(&LOC2), (&NTI190350));
	++fileinfos_190632->Sup.len;
	gcodegenlineinfo_191359 = newlineinfo_191266(((NI32) 1), ((NI) 1), ((NI) 1));
	gnotes_191395 = 0;
	LOC3 = 0;
	for (LOC3 = (((NU16) 237)- 237); LOC3 <= (((NU16) 255)- 237); LOC3++) 
gnotes_191395 |=((NU64)(1)<<((LOC3)%(sizeof(NU64)*8)));
	gnotes_191395 |=((NU64)(1)<<(((((NU16) 257)- 237))%(sizeof(NU64)*8)));
	gnotes_191395 |=((NU64)(1)<<(((((NU16) 261)- 237))%(sizeof(NU64)*8)));
	LOC4 = 0;
	for (LOC4 = (((NU16) 263)- 237); LOC4 <= (((NU16) 276)- 237); LOC4++) 
gnotes_191395 |=((NU64)(1)<<((LOC4)%(sizeof(NU64)*8)));
	LOC5 = 0;
	for (LOC5 = (((NU16) 281)- 237); LOC5 <= (((NU16) 283)- 237); LOC5++) 
gnotes_191395 |=((NU64)(1)<<((LOC5)%(sizeof(NU64)*8)));
	gnotes_191395 |=((NU64)(1)<<(((((NU16) 285)- 237))%(sizeof(NU64)*8)));
	gnotes_191395 |=((NU64)(1)<<(((((NU16) 290)- 237))%(sizeof(NU64)*8)));
	gerrorcounter_191396 = ((NI) 0);
	ghintcounter_191397 = ((NI) 0);
	gwarncounter_191398 = ((NI) 0);
	gerrormax_191399 = ((NI) 1);
	if (msgcontext_191434) nimGCunrefNoCycle(msgcontext_191434);
	msgcontext_191434 = (TY191417*) newSeqRC1((&NTI191417), 0);
	lasterror_191435 = unknownlineinfo_191408();
	erroroutputs_191437 = 3;
	memset((void*)(&LOC6), 0, sizeof(LOC6));
	LOC6.ClPrc = ((TMP501) (HEX3Aanonymous_196653)); LOC6.ClEnv = NIM_NIL;
	asgnRef((void**) (&errorhandler_176028.ClEnv), LOC6.ClEnv);
	errorhandler_176028.ClPrc = LOC6.ClPrc;
	{
		NIM_BOOL LOC9;
		LOC9 = 0;
		LOC9 = isatty_188426(stderr);
		if (!LOC9) goto LA10;
		gglobaloptions_167132 |= ((NU32)1)<<((((NU8) 21))%(sizeof(NU32)*8));
	}
	LA10: ;
}

NIM_EXTERNC N_NOINLINE(void, compiler_msgsDatInit000)(void) {
static TNimNode* TMP143[6];
static TNimNode* TMP151[3];
static TNimNode* TMP2054[291];
NI TMP2056;
static char* NIM_CONST TMP2055[291] = {
"errUnknown", 
"errIllFormedAstX", 
"errInternal", 
"errCannotOpenFile", 
"errGenerated", 
"errXCompilerDoesNotSupportCpp", 
"errStringLiteralExpected", 
"errIntLiteralExpected", 
"errInvalidCharacterConstant", 
"errClosingTripleQuoteExpected", 
"errClosingQuoteExpected", 
"errTabulatorsAreNotAllowed", 
"errInvalidToken", 
"errLineTooLong", 
"errInvalidNumber", 
"errInvalidNumberOctalCode", 
"errNumberOutOfRange", 
"errNnotAllowedInCharacter", 
"errClosingBracketExpected", 
"errMissingFinalQuote", 
"errIdentifierExpected", 
"errNewlineExpected", 
"errInvalidModuleName", 
"errOperatorExpected", 
"errTokenExpected", 
"errStringAfterIncludeExpected", 
"errRecursiveDependencyX", 
"errOnOrOffExpected", 
"errNoneSpeedOrSizeExpected", 
"errInvalidPragma", 
"errUnknownPragma", 
"errInvalidDirectiveX", 
"errAtPopWithoutPush", 
"errEmptyAsm", 
"errInvalidIndentation", 
"errExceptionExpected", 
"errExceptionAlreadyHandled", 
"errYieldNotAllowedHere", 
"errYieldNotAllowedInTryStmt", 
"errInvalidNumberOfYieldExpr", 
"errCannotReturnExpr", 
"errAttemptToRedefine", 
"errStmtInvalidAfterReturn", 
"errStmtExpected", 
"errInvalidLabel", 
"errInvalidCmdLineOption", 
"errCmdLineArgExpected", 
"errCmdLineNoArgExpected", 
"errInvalidVarSubstitution", 
"errUnknownVar", 
"errUnknownCcompiler", 
"errOnOrOffExpectedButXFound", 
"errOnOffOrListExpectedButXFound", 
"errNoneBoehmRefcExpectedButXFound", 
"errNoneSpeedOrSizeExpectedButXFound", 
"errGuiConsoleOrLibExpectedButXFound", 
"errUnknownOS", 
"errUnknownCPU", 
"errGenOutExpectedButXFound", 
"errArgsNeedRunOption", 
"errInvalidMultipleAsgn", 
"errColonOrEqualsExpected", 
"errExprExpected", 
"errUndeclaredIdentifier", 
"errUndeclaredField", 
"errUndeclaredRoutine", 
"errUseQualifier", 
"errTypeExpected", 
"errSystemNeeds", 
"errExecutionOfProgramFailed", 
"errNotOverloadable", 
"errInvalidArgForX", 
"errStmtHasNoEffect", 
"errXExpectsTypeOrValue", 
"errXExpectsArrayType", 
"errIteratorCannotBeInstantiated", 
"errExprXAmbiguous", 
"errConstantDivisionByZero", 
"errOrdinalTypeExpected", 
"errOrdinalOrFloatTypeExpected", 
"errOverOrUnderflow", 
"errCannotEvalXBecauseIncompletelyDefined", 
"errChrExpectsRange0_255", 
"errDynlibRequiresExportc", 
"errUndeclaredFieldX", 
"errNilAccess", 
"errIndexOutOfBounds", 
"errIndexTypesDoNotMatch", 
"errBracketsInvalidForType", 
"errValueOutOfSetBounds", 
"errFieldInitTwice", 
"errFieldNotInit", 
"errExprXCannotBeCalled", 
"errExprHasNoType", 
"errExprXHasNoType", 
"errCastNotInSafeMode", 
"errExprCannotBeCastedToX", 
"errCommaOrParRiExpected", 
"errCurlyLeOrParLeExpected", 
"errSectionExpected", 
"errRangeExpected", 
"errMagicOnlyInSystem", 
"errPowerOfTwoExpected", 
"errStringMayNotBeEmpty", 
"errCallConvExpected", 
"errProcOnlyOneCallConv", 
"errSymbolMustBeImported", 
"errExprMustBeBool", 
"errConstExprExpected", 
"errDuplicateCaseLabel", 
"errRangeIsEmpty", 
"errSelectorMustBeOfCertainTypes", 
"errSelectorMustBeOrdinal", 
"errOrdXMustNotBeNegative", 
"errLenXinvalid", 
"errWrongNumberOfVariables", 
"errExprCannotBeRaised", 
"errBreakOnlyInLoop", 
"errTypeXhasUnknownSize", 
"errConstNeedsConstExpr", 
"errConstNeedsValue", 
"errResultCannotBeOpenArray", 
"errSizeTooBig", 
"errSetTooBig", 
"errBaseTypeMustBeOrdinal", 
"errInheritanceOnlyWithNonFinalObjects", 
"errInheritanceOnlyWithEnums", 
"errIllegalRecursionInTypeX", 
"errCannotInstantiateX", 
"errExprHasNoAddress", 
"errXStackEscape", 
"errVarForOutParamNeeded", 
"errPureTypeMismatch", 
"errTypeMismatch", 
"errButExpected", 
"errButExpectedX", 
"errAmbiguousCallXYZ", 
"errWrongNumberOfArguments", 
"errXCannotBePassedToProcVar", 
"errXCannotBeInParamDecl", 
"errPragmaOnlyInHeaderOfProc", 
"errImplOfXNotAllowed", 
"errImplOfXexpected", 
"errNoSymbolToBorrowFromFound", 
"errDiscardValueX", 
"errInvalidDiscard", 
"errIllegalConvFromXtoY", 
"errCannotBindXTwice", 
"errInvalidOrderInArrayConstructor", 
"errInvalidOrderInEnumX", 
"errEnumXHasHoles", 
"errExceptExpected", 
"errInvalidTry", 
"errOptionExpected", 
"errXisNoLabel", 
"errNotAllCasesCovered", 
"errUnknownSubstitionVar", 
"errComplexStmtRequiresInd", 
"errXisNotCallable", 
"errNoPragmasAllowedForX", 
"errNoGenericParamsAllowedForX", 
"errInvalidParamKindX", 
"errDefaultArgumentInvalid", 
"errNamedParamHasToBeIdent", 
"errNoReturnTypeForX", 
"errConvNeedsOneArg", 
"errInvalidPragmaX", 
"errXNotAllowedHere", 
"errInvalidControlFlowX", 
"errXisNoType", 
"errCircumNeedsPointer", 
"errInvalidExpression", 
"errInvalidExpressionX", 
"errEnumHasNoValueX", 
"errNamedExprExpected", 
"errNamedExprNotAllowed", 
"errXExpectsOneTypeParam", 
"errArrayExpectsTwoTypeParams", 
"errInvalidVisibilityX", 
"errInitHereNotAllowed", 
"errXCannotBeAssignedTo", 
"errIteratorNotAllowed", 
"errXNeedsReturnType", 
"errNoReturnTypeDeclared", 
"errNoCommand", 
"errInvalidCommandX", 
"errXOnlyAtModuleScope", 
"errXNeedsParamObjectType", 
"errTemplateInstantiationTooNested", 
"errInstantiationFrom", 
"errInvalidIndexValueForTuple", 
"errCommandExpectsFilename", 
"errMainModuleMustBeSpecified", 
"errXExpected", 
"errTIsNotAConcreteType", 
"errInvalidSectionStart", 
"errGridTableNotImplemented", 
"errGeneralParseError", 
"errNewSectionExpected", 
"errWhitespaceExpected", 
"errXisNoValidIndexFile", 
"errCannotRenderX", 
"errVarVarTypeNotAllowed", 
"errInstantiateXExplicitly", 
"errOnlyACallOpCanBeDelegator", 
"errUsingNoSymbol", 
"errMacroBodyDependsOnGenericTypes", 
"errDestructorNotGenericEnough", 
"errInlineIteratorsAsProcParams", 
"errXExpectsTwoArguments", 
"errXExpectsObjectTypes", 
"errXcanNeverBeOfThisSubtype", 
"errTooManyIterations", 
"errCannotInterpretNodeX", 
"errFieldXNotFound", 
"errInvalidConversionFromTypeX", 
"errAssertionFailed", 
"errCannotGenerateCodeForX", 
"errXRequiresOneArgument", 
"errUnhandledExceptionX", 
"errCyclicTree", 
"errXisNoMacroOrTemplate", 
"errXhasSideEffects", 
"errIteratorExpected", 
"errLetNeedsInit", 
"errThreadvarCannotInit", 
"errWrongSymbolX", 
"errIllegalCaptureX", 
"errXCannotBeClosure", 
"errXMustBeCompileTime", 
"errCannotInferTypeOfTheLiteral", 
"errCannotInferReturnType", 
"errGenericLambdaNotAllowed", 
"errCompilerDoesntSupportTarget", 
"errExternalAssemblerNotFound", 
"errExternalAssemblerNotValid", 
"errUser", 
"warnCannotOpenFile", 
"warnOctalEscape", 
"warnXIsNeverRead", 
"warnXmightNotBeenInit", 
"warnDeprecated", 
"warnConfigDeprecated", 
"warnSmallLshouldNotBeUsed", 
"warnUnknownMagic", 
"warnRedefinitionOfLabel", 
"warnUnknownSubstitutionX", 
"warnLanguageXNotSupported", 
"warnFieldXNotSupported", 
"warnCommentXIgnored", 
"warnNilStatement", 
"warnTypelessParam", 
"warnUseBase", 
"warnWriteToForeignHeap", 
"warnUnsafeCode", 
"warnEachIdentIsTuple", 
"warnShadowIdent", 
"warnProveInit", 
"warnProveField", 
"warnProveIndex", 
"warnGcUnsafe", 
"warnGcUnsafe2", 
"warnUninit", 
"warnGcMem", 
"warnDestructor", 
"warnLockLevel", 
"warnResultShadowed", 
"warnUser", 
"hintSuccess", 
"hintSuccessX", 
"hintLineTooLong", 
"hintXDeclaredButNotUsed", 
"hintConvToBaseNotNeeded", 
"hintConvFromXtoItselfNotNeeded", 
"hintExprAlwaysX", 
"hintQuitCalled", 
"hintProcessing", 
"hintCodeBegin", 
"hintCodeEnd", 
"hintConf", 
"hintPath", 
"hintConditionAlwaysTrue", 
"hintName", 
"hintPattern", 
"hintExecuting", 
"hintLinking", 
"hintDependency", 
"hintSource", 
"hintStackTrace", 
"hintGCStats", 
"hintUser"};
static TNimNode TMP19[306];
NTI190350.size = sizeof(Tfileinfo190350);
NTI190350.kind = 18;
NTI190350.base = 0;
NTI190350.flags = 2;
TMP143[0] = &TMP19[1];
TMP19[1].kind = 1;
TMP19[1].offset = offsetof(Tfileinfo190350, fullpath);
TMP19[1].typ = (&NTI149);
TMP19[1].name = "fullPath";
TMP143[1] = &TMP19[2];
TMP19[2].kind = 1;
TMP19[2].offset = offsetof(Tfileinfo190350, projpath);
TMP19[2].typ = (&NTI149);
TMP19[2].name = "projPath";
TMP143[2] = &TMP19[3];
TMP19[3].kind = 1;
TMP19[3].offset = offsetof(Tfileinfo190350, shortname);
TMP19[3].typ = (&NTI149);
TMP19[3].name = "shortName";
TMP143[3] = &TMP19[4];
TMP19[4].kind = 1;
TMP19[4].offset = offsetof(Tfileinfo190350, quotedname);
TMP19[4].typ = (&NTI176007);
TMP19[4].name = "quotedName";
TMP143[4] = &TMP19[5];
NTI190365.size = sizeof(TY190365*);
NTI190365.kind = 24;
NTI190365.base = (&NTI176007);
NTI190365.flags = 2;
NTI190365.marker = TMP144;
TMP19[5].kind = 1;
TMP19[5].offset = offsetof(Tfileinfo190350, lines);
TMP19[5].typ = (&NTI190365);
TMP19[5].name = "lines";
TMP143[5] = &TMP19[6];
TMP19[6].kind = 1;
TMP19[6].offset = offsetof(Tfileinfo190350, dirtyfile);
TMP19[6].typ = (&NTI149);
TMP19[6].name = "dirtyfile";
TMP19[0].len = 6; TMP19[0].kind = 2; TMP19[0].sons = &TMP143[0];
NTI190350.node = &TMP19[0];
NTI190615.size = sizeof(TY190615*);
NTI190615.kind = 24;
NTI190615.base = (&NTI190350);
NTI190615.flags = 2;
NTI190615.marker = TMP145;
NTI190352.size = sizeof(Tlineinfo190352);
NTI190352.kind = 18;
NTI190352.base = 0;
NTI190352.flags = 3;
TMP151[0] = &TMP19[8];
TMP19[8].kind = 1;
TMP19[8].offset = offsetof(Tlineinfo190352, line);
TMP19[8].typ = (&NTI112);
TMP19[8].name = "line";
TMP151[1] = &TMP19[9];
TMP19[9].kind = 1;
TMP19[9].offset = offsetof(Tlineinfo190352, col);
TMP19[9].typ = (&NTI112);
TMP19[9].name = "col";
TMP151[2] = &TMP19[10];
TMP19[10].kind = 1;
TMP19[10].offset = offsetof(Tlineinfo190352, fileindex);
TMP19[10].typ = (&NTI114);
TMP19[10].name = "fileIndex";
TMP19[7].len = 3; TMP19[7].kind = 2; TMP19[7].sons = &TMP151[0];
NTI190352.node = &TMP19[7];
NTI191417.size = sizeof(TY191417*);
NTI191417.kind = 24;
NTI191417.base = (&NTI190352);
NTI191417.flags = 2;
NTI191417.marker = TMP152;
NTI190358.size = sizeof(Erecoverableerror190358);
NTI190358.kind = 17;
NTI190358.base = (&NTI4049);
TMP19[11].len = 0; TMP19[11].kind = 2;
NTI190358.node = &TMP19[11];
NTI191373.size = sizeof(Erecoverableerror190358*);
NTI191373.kind = 22;
NTI191373.base = (&NTI190358);
NTI191373.marker = TMP499;
NTI190005.size = sizeof(NU16);
NTI190005.kind = 14;
NTI190005.base = 0;
NTI190005.flags = 3;
for (TMP2056 = 0; TMP2056 < 291; TMP2056++) {
TMP19[TMP2056+12].kind = 1;
TMP19[TMP2056+12].offset = TMP2056;
TMP19[TMP2056+12].name = TMP2055[TMP2056];
TMP2054[TMP2056] = &TMP19[TMP2056+12];
}
TMP19[303].len = 291; TMP19[303].kind = 2; TMP19[303].sons = &TMP2054[0];
NTI190005.node = &TMP19[303];
NTI190346.size = sizeof(NU16);
NTI190346.kind = 20;
NTI190346.base = (&NTI190005);
NTI190346.flags = 3;
NTI190348.size = sizeof(NU64);
NTI190348.kind = 19;
NTI190348.base = (&NTI190346);
NTI190348.flags = 3;
TMP19[304].len = 237; TMP19[304].kind = 0;
NTI190348.node = &TMP19[304];
NTI190360.size = sizeof(Esuggestdone190360);
NTI190360.kind = 17;
NTI190360.base = (&NTI4027);
TMP19[305].len = 0; TMP19[305].kind = 2;
NTI190360.node = &TMP19[305];
NTI191512.size = sizeof(Esuggestdone190360*);
NTI191512.kind = 22;
NTI191512.base = (&NTI190360);
NTI191512.marker = TMP2771;
}

